Index: Users/hamraz.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>hamraz\r\n123\r\nhamraz\r\n0\r\n5000000000
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Users/hamraz.txt	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ Users/hamraz.txt	(date 1624609986002)
@@ -1,5 +1,5 @@
 hamraz
 123
 hamraz
-0
-5000000000
\ No newline at end of file
+3000
+3338200
\ No newline at end of file
Index: src/main/java/controller/DuelController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport controller.exeption.*;\r\nimport model.*;\r\nimport view.DuelView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\npublic class DuelController {\r\n\r\n    public static final int[] playerGroundNumbers = {3, 4, 2, 5, 1};\r\n    public static final int[] opponentGroundNumbers = {3, 2, 4, 1, 5};\r\n    private User player;\r\n    private User rival;\r\n    private Round[] rounds;\r\n    private final int roundNumber;\r\n    private SelectedCard selectedCard;\r\n    private int roundCounter;\r\n    private Phase phase;\r\n    private boolean hasSummonedOrSetInThisTurn;\r\n    private ArrayList<ArrayList<ActionsDoneInTurn>> actionsOnThisCardPlayer = new ArrayList<>(5);\r\n    //    private ArrayList<ArrayList<ActionsDoneInTurn>> actionsOnThisCardRival=new ArrayList<>(5);\r\n    private Integer[] playerAttackPoints = new Integer[5];\r\n    private Integer[] rivalAttackPoints = new Integer[5];\r\n    private Integer[] playerDefencePoints = new Integer[5];\r\n    private Integer[] rivalDefencePoints = new Integer[5];\r\n    /*private boolean hasUsedHeraldInThisTurn;\r\n    private boolean hasUsedTexChangerInThisTurn;*/\r\n    /*boolean[] hasChangedPositionInThisTurn;\r\n    boolean[] hasSetInThisTurn;\r\n    boolean[] hasAttackedInThisTurn;*/\r\n//    MonsterZone monsterZone;\r\n    boolean isStartTurn;\r\n    private boolean shouldEndGameForView;\r\n    //TODO check frequently: cancel, unselect, printBoard\r\n\r\n    public DuelController(User player, User rival, int roundNumber) {\r\n        this.player = player;\r\n        this.rival = rival;\r\n        setGameDeck(this.player);\r\n        setGameDeck(this.rival);\r\n        this.rounds = new Round[roundNumber];\r\n        this.roundNumber = roundNumber;\r\n        this.roundCounter = 0;\r\n//        this.monsterZone = new MonsterZone(this);\r\n        newActionsOnThisCardPlayer();\r\n        startNewGame(null);\r\n    }\r\n\r\n    private void newActionsOnThisCardPlayer() {\r\n        ArrayList<ActionsDoneInTurn> arrayList = new ArrayList<>();\r\n        for (int i = 0; i < 5; i++) {\r\n            this.actionsOnThisCardPlayer.add(arrayList);\r\n        }\r\n    }\r\n\r\n    private void setGameDeck(User user) {\r\n        Deck deck;\r\n        if (user.getDeckByName(\"@\" + user.getActiveDeck().getDeckName()) == null) {\r\n            deck = new Deck(\"@\" + user.getActiveDeck().getDeckName());\r\n        } else {\r\n            deck = user.getDeckByName(\"@\" + user.getActiveDeck().getDeckName());\r\n            user.removeDeck(deck);\r\n        }\r\n        ArrayList<Cardable> mainCards = new ArrayList<>(user.getActiveDeck().getMainDeck());\r\n        ArrayList<Cardable> sideCards = new ArrayList<>(user.getActiveDeck().getSideDeck());\r\n        deck.setDeck(mainCards, sideCards);\r\n        user.addDeck(deck);\r\n        user.setGameDeck(deck);\r\n    }\r\n\r\n    public User getPlayer() {\r\n        return this.player;\r\n    }\r\n\r\n    public User getRival() {\r\n        return this.rival;\r\n    }\r\n\r\n    public void setPlayer(User player) {\r\n        this.player = player;\r\n    }\r\n\r\n    public void setRival(User rival) {\r\n        this.rival = rival;\r\n    }\r\n\r\n    public boolean getHasEnabledSuijin(int i) {\r\n        return actionsOnThisCardPlayer.get(i).contains(ActionsDoneInTurn.ENABLE_SUIJIN);\r\n    }\r\n\r\n    public void setHasEnabledSuijinTrue(int i) {\r\n        actionsOnThisCardPlayer.get(i).add(ActionsDoneInTurn.ENABLE_SUIJIN);\r\n    }\r\n\r\n    public void setMonsterAttackPlayer(int i, Integer number) {\r\n        this.playerAttackPoints[i] = number;\r\n    }\r\n\r\n    public void setMonsterAttackRival(int i, Integer number) {\r\n        this.rivalAttackPoints[i] = number;\r\n    }\r\n\r\n    /*public MonsterZone getMonsterZone() {\r\n        return this.monsterZone;\r\n    }*/\r\n\r\n    public SelectedCard getSelectedCard() {\r\n        return this.selectedCard;\r\n    }\r\n\r\n    public boolean getShouldEndGameForView() {\r\n        return this.shouldEndGameForView;\r\n    }\r\n\r\n    public static int[] getOpponentGroundNumbers() {\r\n        return opponentGroundNumbers;\r\n    }\r\n\r\n    public static int[] getPlayerGroundNumbers() {\r\n        return playerGroundNumbers;\r\n    }\r\n\r\n\r\n    /*public boolean getHasUsedHeraldInThisTurn() {\r\n        return this.hasUsedHeraldInThisTurn;\r\n    }\r\n\r\n    public void setHasHasUsedHeraldInThisTurnTrue() {\r\n        this.hasUsedHeraldInThisTurn = true;\r\n    }\r\n\r\n    public boolean getHasUsedTexChangerInThisTurn() {\r\n        return this.hasUsedTexChangerInThisTurn;\r\n    }\r\n\r\n    public void setHasUsedTexChangerInThisTurn() {\r\n        this.hasUsedTexChangerInThisTurn = true;\r\n    }*/\r\n\r\n    //TODO age vaght shod choose first player random\r\n    public void startNewGame(User winner) {\r\n        if (winner != null) {\r\n            User loser;\r\n            if (winner.equals(this.player)) {\r\n                loser = this.rival;\r\n            } else {\r\n                loser = this.player;\r\n            }\r\n            this.player = loser;\r\n            this.rival = winner;\r\n        } else this.isStartTurn = true;\r\n        this.player.setNewBoard();\r\n        this.rival.setNewBoard();\r\n        clearLastTurn();\r\n        startDrawPhase(true);\r\n    }\r\n\r\n    public void selectCardPlayerMonsterZone(int address) throws Exception {\r\n        MonsterCard[] monsters = this.player.getBoard().getMonsters();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (monsters[address] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.player.getBoard().getMonsterByNumber(address), BoardZone.MONSTERZONE, address, this.player);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardOpponentMonsterZone(int address) throws Exception {\r\n        MonsterCard[] monsters = this.rival.getBoard().getMonsters();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = opponentGroundNumbers[address - 1] - 1;\r\n        if (monsters[address - 1] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.rival.getBoard().getMonsterByNumber(address), BoardZone.MONSTERZONE, address, this.rival);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardPlayerTrapAndSpellZone(int address) throws Exception {\r\n        Cardable[] spellAndTrap = this.player.getBoard().getSpellsAndTraps();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (spellAndTrap[address - 1] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.player.getBoard().getSpellAndTrapByNumber(address), BoardZone.SPELLANDTRAPZONE, address, this.player);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardOpponentTrapAndSpellZone(int address) throws Exception {\r\n        Cardable[] spellAndTrap = this.rival.getBoard().getSpellsAndTraps();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = opponentGroundNumbers[address - 1] - 1;\r\n        if (spellAndTrap[address - 1] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.rival.getBoard().getSpellAndTrapByNumber(address), BoardZone.SPELLANDTRAPZONE, address, this.rival);\r\n\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardPlayerFieldZone() throws Exception {\r\n        Cardable fieldZone = this.player.getBoard().getFieldZone();\r\n        if (fieldZone == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.player.getBoard().getFieldZone(), BoardZone.FIELDZONE, 1, this.player);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardOpponentFieldZone() throws Exception {\r\n        Cardable fieldZone = this.player.getBoard().getFieldZone();\r\n        if (fieldZone == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.rival.getBoard().getFieldZone(), BoardZone.FIELDZONE, 1, this.rival);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardPlayerHand(int address) throws Exception {\r\n        List<Cardable> cardsInHand = this.player.getBoard().getCardsInHand();\r\n        if ((address > cardsInHand.size()) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        } else if (cardsInHand.get(address - 1) == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        }\r\n        this.selectedCard = new SelectedCard(this.player.getBoard().getCardInHandByNumber(address - 1), BoardZone.HAND, address - 1, this.player);\r\n        DuelView.printText(\"card selected\");\r\n    }\r\n\r\n    private void unselectCard() throws Exception {\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        } else {\r\n            this.selectedCard = null;\r\n        }\r\n    }\r\n\r\n    public void setSelectedCard(SelectedCard selectedCard) {\r\n        this.selectedCard = selectedCard;\r\n    }\r\n\r\n    public void unselectCardFromCommand() throws Exception {\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        } else {\r\n            this.selectedCard = null;\r\n            DuelView.printText(\"card deselected\");\r\n        }\r\n    }\r\n\r\n    public int getCountOfMonsterCardsInGround(User user) {\r\n        MonsterCard[] monsterCards = user.getBoard().getMonsters();\r\n        int countOfMonsterCardsInGround = 0;\r\n        for (int i = 0; i < 5; i++) {\r\n            if (monsterCards[i] != null) {\r\n                countOfMonsterCardsInGround++;\r\n            }\r\n        }\r\n        return countOfMonsterCardsInGround;\r\n    }\r\n\r\n    public void summonMonster() throws Exception {\r\n        //TODO special va ritual summon\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        }\r\n        //TODO in exception payinie halate \"مد نظر قابلیت احضار عادی را نداشته باشد monster\" ro nadare hanooz(fekr konam dare alan)\r\n        if (!(this.selectedCard.getCard() instanceof MonsterCard && this.selectedCard.getBoardZone().equals(BoardZone.HAND) && !((MonsterCard) this.selectedCard.getCard()).getCardType().equals(CardType.RITUAL))) {\r\n            throw new CanNotSummon();\r\n        }\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2)))) {\r\n            throw new ActionNotAllowedInThisPhase();\r\n        }\r\n        if (this.player.getBoard().isFullMonsterZone()) {\r\n            throw new FullMonsterZone();\r\n        }\r\n        if (((MonsterCard) this.selectedCard.getCard()).getCanBeNormalSummoned()) {\r\n            if (hasSummonedOrSetInThisTurn) {\r\n                throw new AlreadySummoned();\r\n            }\r\n            MonsterCard monsterCard = (MonsterCard) selectedCard.getCard();\r\n            if (monsterCard.getLevel() <= 4) {\r\n                this.player.getBoard().putMonster(monsterCard, \"OO\");\r\n                monsterCard.takeAction(this, TakeActionCase.SUMMONED, this.player, this.selectedCard.getNumber());\r\n                this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n                unselectCard();\r\n                DuelView.printText(\"summoned successfully\");\r\n                hasSummonedOrSetInThisTurn = true;\r\n                return;\r\n            }\r\n            if (monsterCard.getLevel() < 7) {\r\n                if (getCountOfMonsterCardsInGround(this.player) < 1) {\r\n                    throw new InsufficientForTribute();\r\n                } else {\r\n                    tributeOneMonsterForSummon();\r\n                }\r\n            } else {\r\n                if (getCountOfMonsterCardsInGround(this.player) < 2) {\r\n                    throw new InsufficientForTribute();\r\n                } else {\r\n                    tributeTwoMonstersForSummon();\r\n                }\r\n            }\r\n        } else if (!((MonsterCard) this.selectedCard.getCard()).getCardType().equals(CardType.RITUAL)) {\r\n            specialSummonNormal();\r\n        }\r\n    }\r\n\r\n    private void tributeOneMonsterForSummon() throws Exception {\r\n        String input = DuelView.scan();\r\n        if (input.equals(\"cancel\")) return;\r\n        int address = Integer.parseInt(input);\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address) == null) throw new NoMonsterHere1();\r\n        this.player.getBoard().removeMonster(address);\r\n        removeMonsterPlayer(address);\r\n        this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"OO\");\r\n        ((MonsterCard) selectedCard.getCard()).takeAction(this, TakeActionCase.SUMMONED, this.player, this.selectedCard.getNumber());\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"summoned successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n    }\r\n\r\n    private void tributeTwoMonstersForSummon() throws Exception {\r\n        String input1 = DuelView.scan();\r\n        if (input1.equals(\"cancel\")) return;\r\n        int address1 = Integer.parseInt(input1) - 1;\r\n        address1 = playerGroundNumbers[address1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address1) == null) throw new NoMonsterHere1();\r\n        String input2 = DuelView.scan();\r\n        if (input2.equals(\"cancel\")) return;\r\n        int address2 = Integer.parseInt(input2) - 1;\r\n        address2 = playerGroundNumbers[address2] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address2) == null) throw new NoMonsterHere1();\r\n        if (address1 == address2) throw new sameAddresses();\r\n        this.player.getBoard().removeMonster(address1);\r\n        this.player.getBoard().removeMonster(address2);\r\n        removeMonsterPlayer(address1);\r\n        removeMonsterPlayer(address2);\r\n        this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"OO\");\r\n        ((MonsterCard) selectedCard.getCard()).takeAction(this, TakeActionCase.SUMMONED, this.player, this.selectedCard.getNumber());\r\n        this.player.getBoard().getCardsInHand().remove((int) this.selectedCard.getNumber());\r\n        unselectCard();\r\n        DuelView.printText(\"summoned successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n    }\r\n\r\n    public void specialSummonNormal() throws Exception {\r\n        ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.SPECIAL_SUMMONED, this.player, this.selectedCard.getNumber());\r\n\r\n    }\r\n\r\n    private void specialSummonWithSpell() throws Exception {\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.HAND)) {\r\n            throw new CanNotSpecialSummon();\r\n        }\r\n        /*if (*//*hayula special summon nashod*//*) {\r\n        DuelView.printText(\"you should special summon right now\");\r\n        special summon kone\r\n        }*/\r\n    }\r\n\r\n    public void preSet() throws Exception {\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!(this.selectedCard.getBoardZone().equals(BoardZone.HAND))) throw new CanNotSet();\r\n        if (this.selectedCard.getCard() instanceof MonsterCard) setMonster();\r\n        else if (this.selectedCard.getCard() instanceof SpellCard) setSpell();\r\n        else if (this.selectedCard.getCard() instanceof TrapCard) setTrap();\r\n    }\r\n\r\n    private void setMonster() throws Exception {\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2)))) {\r\n            throw new ImproperPhase();\r\n        }\r\n        if (this.player.getBoard().isFullMonsterZone()) {\r\n            throw new FullMonsterZone();\r\n        }\r\n        if (hasSummonedOrSetInThisTurn) {\r\n            throw new AlreadySummoned();\r\n        }\r\n        MonsterCard monsterCard = (MonsterCard) this.selectedCard.getCard();\r\n        if (monsterCard.getLevel() <= 4) {\r\n            this.actionsOnThisCardPlayer.get(this.player.getBoard().putMonster(monsterCard, \"DH\")).add(ActionsDoneInTurn.SET);\r\n//            monsterZone.setHasSetInThisTurn(this.player.getBoard().putMonster(monsterCard, \"DH\"), true);\r\n            this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n            unselectCard();\r\n            DuelView.printText(\"set successfully\");\r\n            hasSummonedOrSetInThisTurn = true;\r\n            printBoard();\r\n            return;\r\n        }\r\n        if (monsterCard.getLevel() < 7) {\r\n            if (getCountOfMonsterCardsInGround(this.player) < 1) {\r\n                throw new InsufficientForTribute();\r\n            } else {\r\n                tributeOneMonsterForSet();\r\n            }\r\n        } else {\r\n            if (getCountOfMonsterCardsInGround(this.player) < 2) {\r\n                throw new InsufficientForTribute();\r\n            } else {\r\n                tributeTwoMonstersForSet();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void tributeOneMonsterForSet() throws Exception {\r\n        String input = DuelView.scan();\r\n        if (input.equals(\"cancel\")) return;\r\n        int address = Integer.parseInt(input);\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address) == null) throw new NoMonsterHere1();\r\n        this.player.getBoard().removeMonster(address);\r\n        removeMonsterPlayer(address);\r\n        this.actionsOnThisCardPlayer.get(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\")).add(ActionsDoneInTurn.SET);\r\n//        monsterZone.setHasSetInThisTurn(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\"), true);\r\n        this.player.getBoard().getCardsInHand().remove((int) this.selectedCard.getNumber());\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n        printBoard();\r\n    }\r\n\r\n    private void tributeTwoMonstersForSet() throws Exception {\r\n        String input1 = DuelView.scan();\r\n        if (input1.equals(\"cancel\")) return;\r\n        int address1 = Integer.parseInt(input1);\r\n        address1 = playerGroundNumbers[address1 - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address1) == null) throw new NoMonsterHere1();\r\n        String input2 = DuelView.scan();\r\n        if (input2.equals(\"cancel\")) return;\r\n        int address2 = Integer.parseInt(input2);\r\n        address2 = playerGroundNumbers[address2 - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address2) == null) throw new NoMonsterHere1();\r\n        if (address1 == address2) throw new sameAddresses();\r\n        this.player.getBoard().getCardsInHand().remove((int) this.selectedCard.getNumber());\r\n        this.player.getBoard().removeMonster(address1);\r\n        this.player.getBoard().removeMonster(address2);\r\n        removeMonsterPlayer(address1);\r\n        removeMonsterPlayer(address2);\r\n        this.actionsOnThisCardPlayer.get(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\")).add(ActionsDoneInTurn.SET);\r\n//        monsterZone.setHasSetInThisTurn(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\"), true);\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n        printBoard();\r\n    }\r\n\r\n    private void setSpell() throws Exception {\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new ImproperPhase();\r\n        SpellCard spellCard = (SpellCard) this.selectedCard.getCard();\r\n        if (!spellCard.getIcon().equals(Icon.FIELD)) {\r\n            if (this.player.getBoard().isFullSpellAndTrapZone())\r\n                throw new FullSpellZone();\r\n            this.player.getBoard().putSpellOrTrap(spellCard, \"H\");\r\n        } else {\r\n            if (this.player.getBoard().getFieldZone() != null) {\r\n                this.player.getBoard().putInGraveYard(this.player.getBoard().getFieldZone());\r\n                this.player.getBoard().removeFromFieldZone();\r\n            }\r\n            this.player.getBoard().putInFieldZone(spellCard);\r\n        }\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    private void setTrap() throws Exception {\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new ImproperPhase();\r\n        TrapCard trapCard = (TrapCard) this.selectedCard.getCard();\r\n        if (!trapCard.getIcon().equals(Icon.FIELD)) {\r\n            if (this.player.getBoard().isFullSpellAndTrapZone()) {\r\n                throw new FullSpellZone();\r\n            }\r\n            this.player.getBoard().putSpellOrTrap(trapCard, \"H\");\r\n        } else {\r\n            if (this.player.getBoard().getFieldZone() != null) {\r\n                this.player.getBoard().putInGraveYard(this.player.getBoard().getFieldZone());\r\n                this.player.getBoard().removeFromFieldZone();\r\n            }\r\n            this.player.getBoard().putInFieldZone(trapCard);\r\n        }\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    public void changePosition(String targetPosition) throws Exception {\r\n        String targetPositionInShort = \"\";\r\n        switch (targetPosition) {\r\n            case \"attack\":\r\n                targetPositionInShort = \"OO\";\r\n                break;\r\n            case \"defence\":\r\n                targetPositionInShort = \"DO\";\r\n                break;\r\n        }\r\n        if (this.selectedCard == null)\r\n            throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE) || this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"DH\"))\r\n            throw new CanNotChangePosition();\r\n        if (!(this.phase.equals(Phase.MAIN_PHASE1) || (this.phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new CantDoActionInThisPhase();\r\n        if (this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(targetPositionInShort) || this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"DH\"))\r\n            throw new AlreadyInWantedPosition();\r\n        if (actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.CHANGE_POSITION))\r\n            throw new AlreadyChangedPosition();\r\n        if (actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.ATTACK) && this.phase.equals(Phase.MAIN_PHASE2))\r\n            throw new HasAttackedInBattle();\r\n        this.player.getBoard().changeMonsterPosition(this.selectedCard.getNumber(), targetPositionInShort);\r\n        actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.CHANGE_POSITION);\r\n//        monsterZone.setHasChangedPositionInThisTurn(this.selectedCard.getNumber(), true);\r\n        DuelView.printText(\"monster card position changed successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    public void flipSummon() throws Exception {\r\n        if (this.selectedCard == null)\r\n            throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE))\r\n            throw new CanNotChangePosition();\r\n        if (!(this.phase.equals(Phase.MAIN_PHASE1) || this.phase.equals(Phase.MAIN_PHASE2)))\r\n            throw new CantDoActionInThisPhase();\r\n        if (!this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"DH\") || actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.SET))\r\n            throw new CanNotFlipSummon();\r\n        this.player.getBoard().changeMonsterPosition(this.selectedCard.getNumber(), \"OO\");\r\n        ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.FLIP_SUMMONED, this.player, this.selectedCard.getNumber());\r\n        unselectCard();\r\n        DuelView.printText(\"flip summoned successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    public void attackMonster(int monsterNumber) throws Exception {\r\n        monsterNumber = opponentGroundNumbers[monsterNumber - 1] - 1;\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!(this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE) && (this.selectedCard.getCard() instanceof MonsterCard) && (this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"OO\"))))\r\n            throw new CanNotAttack();\r\n        if (!(this.phase.equals(Phase.BATTLE_PHASE)))\r\n            throw new CantDoActionInThisPhase();\r\n        if (actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.ATTACK))\r\n            throw new AlreadyAttacked();\r\n        if (getCountOfMonsterCardsInGround(this.rival) == 0)\r\n            throw new NoCardToAttack();\r\n        String targetPosition = this.rival.getBoard().getMonsterConditionByNumber(monsterNumber);\r\n        if (this.rival.getBoard().getMonsterByNumber(monsterNumber).canBeAttacked(this, monsterNumber)) {\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.ATTACKED, this.rival, monsterNumber);\r\n            switch (targetPosition) {\r\n                case \"OO\":\r\n                    attackMonsterOO(monsterNumber);\r\n                    break;\r\n                case \"DO\":\r\n                    attackMonsterDO(monsterNumber);\r\n                    break;\r\n                case \"DH\":\r\n                    attackMonsterDH(monsterNumber);\r\n                    break;\r\n            }\r\n        } else throw new CanNotAttackThisCard();\r\n    }\r\n\r\n    private void attackMonsterOO(int monsterNumber) throws Exception {\r\n        int attackerAttack = this.playerAttackPoints[this.selectedCard.getNumber()];\r\n        int targetAttack = this.rivalAttackPoints[monsterNumber];\r\n        if (attackerAttack > targetAttack) {\r\n            int damage = attackerAttack - targetAttack;\r\n            if (!this.rival.getBoard().getMonsterByNumber(monsterNumber).equals(MonsterCard.EXPLODER_DRAGON))\r\n                this.rival.decreaseLifePoint(damage);\r\n            this.rival.getBoard().putInGraveYard(this.rival.getBoard().getMonsterByNumber(monsterNumber));\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"your opponent’s monster is destroyed and your opponent receives \" + damage + \" battle damage\");\r\n        } else if (attackerAttack == targetAttack) {\r\n            this.rival.getBoard().putInGraveYard(this.rival.getBoard().getMonsterByNumber(monsterNumber));\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            if (this.player.getBoard().getMonsterByNumber(this.selectedCard.getNumber()) != null) {\r\n                this.player.getBoard().putInGraveYard(this.selectedCard.getCard());\r\n                this.player.getBoard().removeMonster(this.selectedCard.getNumber());\r\n                removeMonsterPlayer(this.selectedCard.getNumber());\r\n            }\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"both you and your opponent monster cards are destroyed and no one receives damage\");\r\n        } else {\r\n            int damage = targetAttack - attackerAttack;\r\n            this.player.decreaseLifePoint(damage);\r\n            ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.REMOVE_FROM_MONSTERZONE, this.player, this.selectedCard.getNumber());\r\n            this.player.getBoard().putInGraveYard(this.selectedCard.getCard());\r\n            this.player.getBoard().removeMonster(this.selectedCard.getNumber());\r\n            removeMonsterPlayer(this.selectedCard.getNumber());\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"Your monster card is destroyed and you received\" + damage + \"battle damage\");\r\n        }\r\n        unselectCard();\r\n        printBoard();\r\n    }\r\n\r\n    private void attackMonsterDO(int monsterNumber) throws Exception {\r\n        MonsterCard target = this.rival.getBoard().getMonsterByNumber(monsterNumber);\r\n        int attackerAttack = this.playerAttackPoints[this.selectedCard.getNumber()];\r\n        if (attackerAttack > target.getDefence()) {\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            this.rival.getBoard().putInGraveYard(target);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"the defense position monster is destroyed\");\r\n        } else if (attackerAttack == target.getDefence()) {\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"no card is destroyed\");\r\n        } else {\r\n            int damage = target.getDefence() - attackerAttack;\r\n            this.player.decreaseLifePoint(damage);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"no card is destroyed and you received\" + damage + \" battle damage\");\r\n        }\r\n        unselectCard();\r\n        printBoard();\r\n    }\r\n\r\n    private void attackMonsterDH(int monsterNumber) throws Exception {\r\n        MonsterCard target = this.rival.getBoard().getMonsterByNumber(monsterNumber);\r\n        int attackerAttack = this.playerAttackPoints[this.selectedCard.getNumber()];\r\n        String targetName = this.rival.getBoard().getMonsterByNumber(monsterNumber).getName();\r\n        this.rival.getBoard().changeMonsterPosition(monsterNumber, \"DO\");\r\n        ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.FLIP_SUMMONED, this.rival, this.selectedCard.getNumber());\r\n        if (attackerAttack > target.getDefence()) {\r\n            this.rival.getBoard().putInGraveYard(target);\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"opponent’s monster card was \" + targetName + \" and the defense position monster is destroyed\");\r\n        } else if (attackerAttack == target.getDefence()) {\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"opponent’s monster card was \" + targetName + \" and no card is destroyed\");\r\n        } else {\r\n            int damage = target.getDefence() - attackerAttack;\r\n            this.player.decreaseLifePoint(damage);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"opponent’s monster card was \" + targetName + \" and no card is destroyed and you received\" + damage + \" battle damage\");\r\n        }\r\n        unselectCard();\r\n        printBoard();\r\n    }\r\n\r\n    public void directAttack() throws Exception {\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE)) throw new CanNotAttack();\r\n        if (!this.phase.equals(Phase.BATTLE_PHASE)) throw new ImproperPhase();\r\n        int countOfMonsterCardsInGround = getCountOfMonsterCardsInGround(this.rival);\r\n        if (countOfMonsterCardsInGround == 0) {\r\n            rival.decreaseLifePoint(((MonsterCard) this.selectedCard.getCard()).getAttack());\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            unselectCard();\r\n            printBoard();\r\n        } else throw new CanNotAttackDirectly();\r\n        printBoard();\r\n    }\r\n\r\n    public void activateSpell() throws Exception {\r\n        if (this.selectedCard == null)\r\n            throw new NoCardSelected();\r\n        if (!(this.selectedCard.getCard() instanceof SpellCard))\r\n            throw new IsNotSpell();\r\n        if (!((this.phase.equals(Phase.MAIN_PHASE1)) || (this.phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new CanNotActivateEffectOnThisTurn();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.HAND) && this.player.getBoard().getSpellAndTrapConditionByNumber(this.selectedCard.getNumber()).equals(\"O\"))\r\n            throw new AlreadyActivated();\r\n        SpellCard spellCard = (SpellCard) this.selectedCard.getCard();\r\n        if (this.player.getBoard().isFullSpellAndTrapZone() && !spellCard.getIcon().equals(Icon.FIELD))\r\n            throw new FullSpellZone();\r\n        //TODO maybe complete next condition\r\n        if ((((SpellCard) this.selectedCard.getCard()).getIcon().equals(Icon.QUICK_PLAY)\r\n                && actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.SET)))\r\n            throw new UndonePreparationOfSpell();\r\n        if (spellCard.getIcon().equals(Icon.FIELD)) {\r\n            if (this.player.getBoard().getFieldZone() != null) {\r\n                if (((SpellCard) this.player.getBoard().getFieldZone()).takeAction(this, TakeActionCase.REMOVE_FROM_FIELDZONE_FACE_UP, this.player, 1))\r\n                    this.player.getBoard().putInGraveYard(this.player.getBoard().getFieldZone());\r\n                this.player.getBoard().removeFromFieldZone();\r\n            }\r\n            //TODO age lazeme condition ham pas bede\r\n            if (((SpellCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.PUT_IN_FIELDZONE_FACE_UP, this.player, 1))\r\n                this.player.getBoard().putInFieldZone(spellCard);\r\n\r\n        } else {\r\n            int number = this.player.getBoard().putSpellOrTrap(spellCard, \"O\");\r\n            if (!((SpellCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.PUT_IN_SPELLTRAPZONE, this.player, number)) {\r\n                this.player.getBoard().removeSpellOrTrap(number);\r\n            }\r\n        }\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"spell activated\");\r\n        printBoard();\r\n    }\r\n\r\n    private void ritualSummon() throws Exception {\r\n\r\n\r\n    }\r\n\r\n    private void activateSpellOrTrapInRivalsTurn() throws Exception {\r\n        /*sharayet bar ghara bud*/\r\n        if (true) {\r\n            DuelView.printText(\"do you want to activate your trap and spell?\");\r\n            String input = DuelView.scan();\r\n            if (input.equals(\"yes\")) {\r\n//                if (/*kare digei anjam shod*/) throw new NotYourTurnForThisAction();\r\n                //faal sazie YEK card ke sharayetesh hast va ru zamine\r\n                DuelView.printText(\"spell/trap activated\");\r\n            } else if (input.equals(\"no\")) {\r\n                DuelView.printText(\"now it will be \" + this.player + \"'s turn\");\r\n                printBoard();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void cheatLifePoint(String target, int lifePoint) {\r\n        if (lifePoint < 2000) {\r\n            if (target.equals(\"player\"))\r\n                this.player.increaseLifePoint(lifePoint);\r\n            if (target.equals(\"opponent\"))\r\n                this.rival.decreaseLifePoint(lifePoint);\r\n            DuelView.printText(\"shame on you for cheating!!!!\");\r\n        }\r\n    }\r\n\r\n    public void cheatMoney(int amount) {\r\n        if (amount <= 5000)\r\n            this.player.increaseMoney(amount);\r\n        DuelView.printText(\"shame on you for cheating!!!!\");\r\n    }\r\n\r\n    public void cheatToWinGame() {\r\n        DuelView.printText(\"this is not a good way to win the game, but ok. Shame on you!\");\r\n        endGame(this.rival);\r\n    }\r\n\r\n    /*private void checkForChangesWhenAttackedMonster(int monsterNumber) {\r\n        switch (this.rival.getBoard().getMonsterByNumber(monsterNumber)) {\r\n            case COMMAND_KNIGHT:\r\n                changeAllAttackPointsBy400(-1);\r\n                break;\r\n        }\r\n    }*/\r\n\r\n    public void changeAllAttackPoints(int increaseOrDecrease, int amount) {\r\n        Board playerBoard = this.player.getBoard();\r\n        Board rivalBoard = this.rival.getBoard();\r\n        for (int i = 0; i < 5; i++) {\r\n            if (playerBoard.getMonsterByNumber(i) != null)\r\n                this.playerAttackPoints[i] = this.playerAttackPoints[i] + increaseOrDecrease * amount;\r\n            if (rivalBoard.getMonsterByNumber(i) != null)\r\n                this.rivalAttackPoints[i] = this.rivalAttackPoints[i] + increaseOrDecrease * amount;\r\n        }\r\n    }\r\n\r\n    public void changePlayerAttackPoint(int address, int amount) {\r\n        this.playerAttackPoints[address] += amount;\r\n    }\r\n\r\n    public void changeRivalAttackPoint(int address, int amount) {\r\n        this.rivalAttackPoints[address] += amount;\r\n    }\r\n\r\n    public void changePlayerDefencePoint(int address, int amount) {\r\n        this.playerDefencePoints[address] += amount;\r\n    }\r\n\r\n    public void changeRivalDefencePoint(int address, int amount) {\r\n        this.rivalDefencePoints[address] += amount;\r\n    }\r\n\r\n    public void surrender() {\r\n        //todo shayad lazem bashe darbare in bishter tafakor konim\r\n        endGame(this.player);\r\n    }\r\n\r\n    public void manageEndGame() {\r\n        List<Cardable> playersCardInHand = player.getBoard().getCardsInHand();\r\n        List<Cardable> rivalsCardInHand = rival.getBoard().getCardsInHand();\r\n        if (player.getLifePoint() <= 0) {\r\n            endGame(player);\r\n        } else if (rival.getLifePoint() <= 0) {\r\n            endGame(rival);\r\n        } else if (playersCardInHand.isEmpty()) {\r\n            endGame(player);\r\n        } else if (rivalsCardInHand.isEmpty()) {\r\n            endGame(rival);\r\n        }\r\n    }\r\n\r\n    private void endGame(User loser) {\r\n        User winner;\r\n        if (loser.equals(rival)) {\r\n            winner = player;\r\n        } else {\r\n            winner = rival;\r\n        }\r\n        roundCounter++;\r\n        if (roundNumber == 1) {\r\n            winner.increaseScore(1000);\r\n            winner.increaseMoney(1000 + winner.getLifePoint());\r\n            loser.increaseMoney(100);\r\n            shouldEndGameForView = true;\r\n            DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n        }\r\n        if (roundNumber == 3) {\r\n            this.rounds[this.roundCounter - 1] = new Round(winner, loser, winner.getLifePoint(), loser.getLifePoint());\r\n            if (this.roundCounter == 2 && this.rounds[0].getWinner().equals(this.rounds[1].getWinner())) {\r\n                int winnerLP1 = this.rounds[0].getLifePointByUser(winner);\r\n                int winnerLP2 = this.rounds[1].getLifePointByUser(winner);\r\n                int maxLP = Math.max(winnerLP1, winnerLP2);\r\n                winner.increaseScore(3000);\r\n                winner.increaseMoney(3000 + (3 * maxLP));\r\n                loser.increaseMoney(300);\r\n                shouldEndGameForView = true;\r\n                DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n                DuelView.printText(winner.getUsername() + \" won the whole match with score: \" + winner.getScore() + \"-\" + loser.getScore());\r\n            } else if (roundCounter == 3) {\r\n                int winnerLP1 = this.rounds[0].getLifePointByUser(winner);\r\n                int winnerLP2 = this.rounds[1].getLifePointByUser(winner);\r\n                int winnerLP3 = this.rounds[2].getLifePointByUser(winner);\r\n                int maxLP = Math.max(winnerLP1, winnerLP2);\r\n                maxLP = Math.max(maxLP, winnerLP3);\r\n                winner.increaseScore(3000);\r\n                winner.increaseMoney(3000 + (3 * maxLP));\r\n                loser.increaseMoney(300);\r\n                shouldEndGameForView = true;\r\n                DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n                DuelView.printText(winner.getUsername() + \" won the whole match with score: \" + winner.getScore() + \"-\" + loser.getScore());\r\n            } else {\r\n                DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n                exchangeCardBetweenMainAndSide(this.player);\r\n                exchangeCardBetweenMainAndSide(this.rival);\r\n                startNewGame(winner);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void exchangeCardBetweenMainAndSide(User user) {\r\n        DuelView.printText(\"Do you want to exchange a card between main and side deck \" + user.getNickname() + \"?\");\r\n        String answer = DuelView.scan().toLowerCase();\r\n        if (answer.equals(\"yes\")) {\r\n            DuelView.printText(\"enter card name from main and side\");\r\n            String main = DuelView.scan();\r\n            Cardable mainCard = user.getCardByName(main);\r\n            while (mainCard == null || !user.getGameDeck().getMainDeck().contains(mainCard)) {\r\n                DuelView.printText(\"Please enter a card you have in your main deck!\");\r\n                main = DuelView.scan();\r\n                mainCard = user.getCardByName(main);\r\n            }\r\n            String side = DuelView.scan();\r\n            Cardable sideCard = user.getCardByName(side);\r\n            while (sideCard == null || !user.getGameDeck().getSideDeck().contains(sideCard)) {\r\n                DuelView.printText(\"Please enter a card you have in your side deck!\");\r\n                side = DuelView.scan();\r\n                sideCard = user.getCardByName(side);\r\n            }\r\n            user.getGameDeck().getSideDeck().remove(sideCard);\r\n            user.getGameDeck().getMainDeck().remove(mainCard);\r\n            user.getGameDeck().getSideDeck().add(mainCard);\r\n            user.getGameDeck().getMainDeck().add(sideCard);\r\n        }\r\n    }\r\n\r\n    public void goNextPhase() {\r\n        //shayad to do in kar dare hala\r\n        if (this.phase.equals(Phase.DRAW_PHASE)) {\r\n            this.phase = Phase.STANDBY_PHASE;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n        } else if (phase.equals(Phase.STANDBY_PHASE)) {\r\n            this.phase = Phase.MAIN_PHASE1;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n            printBoard();\r\n        } else if (phase.equals(Phase.MAIN_PHASE1)) {\r\n            if (!isStartTurn)\r\n                this.phase = Phase.BATTLE_PHASE;\r\n            else\r\n                this.phase = Phase.MAIN_PHASE2;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n        } else if (this.phase.equals(Phase.BATTLE_PHASE)) {\r\n            this.phase = Phase.MAIN_PHASE2;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n        } else if (this.phase.equals(Phase.MAIN_PHASE2)) {\r\n            this.phase = Phase.END_PHASE;\r\n        } else if (this.phase.equals(Phase.END_PHASE)) {\r\n            DuelView.printText(\"phase: \" + phase.getNamePascalCase());\r\n            DuelView.printText(\"its \" + rival.getNickname() + \"’s turn\");\r\n            changeTurn();\r\n            startDrawPhase(false);\r\n        }\r\n    }\r\n\r\n    private void startDrawPhase(boolean isFirstTime) {\r\n        this.phase = Phase.DRAW_PHASE;\r\n        ArrayList<Cardable> playerMainCards = (ArrayList<Cardable>) this.player.getGameDeck().getMainDeck();\r\n        ArrayList<Cardable> rivalMainCards = (ArrayList<Cardable>) this.rival.getGameDeck().getMainDeck();\r\n        if (playerMainCards.size() == 0) endGame(this.player);\r\n        else {\r\n            if (!isFirstTime) {\r\n                this.player.getBoard().addCardToHand(playerMainCards.get(playerMainCards.size() - 1));\r\n                this.player.getGameDeck().removeCardFromMainDeck(playerMainCards.get(playerMainCards.size() - 1));\r\n                Collections.shuffle(this.player.getGameDeck().getMainDeck());\r\n                DuelView.printText(\"new card added to the hand : \" + playerMainCards.get(playerMainCards.size() - 1).getNamePascalCase());\r\n            } else {\r\n                for (int i = 0; i < 5; i++) {\r\n                    this.player.getBoard().addCardToHand(playerMainCards.get(playerMainCards.size() - 1));\r\n                    this.player.getGameDeck().removeCardFromMainDeck(playerMainCards.get(playerMainCards.size() - 1));\r\n                    this.rival.getBoard().addCardToHand(rivalMainCards.get(rivalMainCards.size() - 1));\r\n                    this.rival.getGameDeck().removeCardFromMainDeck(rivalMainCards.get(rivalMainCards.size() - 1));\r\n                }\r\n            }\r\n        }\r\n        goNextPhase();\r\n    }\r\n\r\n    private void changeTurn() {\r\n        if (this.isStartTurn) this.isStartTurn = false;\r\n        clearLastTurn();\r\n        //shayad TO DO inam hanooz kar dare\r\n        User temp = this.player;\r\n        this.player = rival;\r\n        this.rival = temp;\r\n        changePlayerAndRival();\r\n        if (this.player.getUsername().equals(\"@AI@\"))\r\n            handleAITurn();\r\n\r\n    }\r\n\r\n    public void changePlayerAndRival() {\r\n        Integer[] temp = this.playerAttackPoints;\r\n        this.playerAttackPoints = this.rivalAttackPoints;\r\n        this.rivalAttackPoints = temp;\r\n    }\r\n\r\n    private void clearLastTurn() {\r\n        this.selectedCard = null;\r\n        this.hasSummonedOrSetInThisTurn = false;\r\n        /*this.hasUsedHeraldInThisTurn = false;\r\n        this.hasUsedTexChangerInThisTurn = false;*/\r\n        newThoseThatResetWithTurn();\r\n    }\r\n\r\n    private void newThoseThatResetWithTurn() {\r\n        for (int i = 0; i < 5; i++) {\r\n            actionsOnThisCardPlayer.get(i).clear();\r\n            if (this.player.getBoard().getMonsterByNumber(i) != null && this.playerAttackPoints[i] != null && this.playerAttackPoints[i] == 0 && this.player.getBoard().getMonsterByNumber(i).getAttack() != 0) {\r\n                this.playerAttackPoints[i] = this.player.getBoard().getMonsterByNumber(i).getAttack();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void printBoard() {\r\n        String toPrint = this.rival.getNickname() + \":\" + this.rival.getLifePoint() + \"\\n\";\r\n        for (Cardable ignored : this.rival.getBoard().getCardsInHand()) {\r\n            toPrint += \"\\tc\";\r\n        }\r\n        toPrint += \"\\n\";\r\n        toPrint += this.rival.getGameDeck().getMainSize() + \"\\n\";\r\n        for (int i = 4; i > -1; i--) {\r\n            toPrint += \"\\t\";\r\n            if (this.rival.getBoard().getSpellAndTrapConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.rival.getBoard().getSpellAndTrapConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\n\";\r\n        for (int i = 4; i > -1; i--) {\r\n            toPrint += \"\\t\";\r\n            if (this.rival.getBoard().getMonsterConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.rival.getBoard().getMonsterConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\n\" + this.rival.getBoard().getCardsInGraveyard().size() + \"\\t\\t\\t\\t\\t\\t\";\r\n        if (this.rival.getBoard().getFieldZone() == null) toPrint += \"E\\n\";\r\n        else toPrint += \"O\\n\";\r\n        toPrint += \"\\n--------------------------\\n\\n\";\r\n        if (this.player.getBoard().getFieldZone() == null) toPrint += \"E\\t\\t\\t\\t\\t\\t\";\r\n        else toPrint += \"O\\t\\t\\t\\t\\t\\t\";\r\n        toPrint += this.player.getBoard().getCardsInGraveyard().size() + \"\\n\";\r\n        for (int i = 0; i < 5; i++) {\r\n            toPrint += \"\\t\";\r\n            if (this.player.getBoard().getMonsterConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.player.getBoard().getMonsterConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\n\";\r\n        for (int i = 0; i < 5; i++) {\r\n            toPrint += \"\\t\";\r\n            if (this.player.getBoard().getSpellAndTrapConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.player.getBoard().getSpellAndTrapConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\t\\t\\t\\t\\t\\t\" + this.player.getGameDeck().getMainSize() + \"\\n\";\r\n        for (Cardable ignored : this.player.getBoard().getCardsInHand()) {\r\n            toPrint += \"c\\t\";\r\n        }\r\n        toPrint += \"\\n\" + this.player.getNickname() + \":\" + this.player.getLifePoint();\r\n        DuelView.printText(toPrint);\r\n    }\r\n\r\n    public void showCard() throws Exception {\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        } else if (!this.selectedCard.getOwner().equals(this.player)) {\r\n            throw new InvisibleCard();\r\n        } else\r\n            DuelView.printText(this.selectedCard.getCard().toString());\r\n    }\r\n\r\n    public void showGraveyard() throws Exception {\r\n        List<Cardable> graveyard = this.player.getBoard().getCardsInGraveyard();\r\n        String toPrint = \"\";\r\n        if (graveyard.isEmpty())\r\n            throw new GraveYardEmpty();\r\n        else {\r\n            for (Cardable cardInGraveyard : graveyard) {\r\n                if (graveyard.indexOf(cardInGraveyard) == graveyard.size() - 1) {\r\n                    toPrint += cardInGraveyard.getName() + \":\" + cardInGraveyard.getDescription();\r\n                } else {\r\n                    toPrint += cardInGraveyard.getName() + \":\" + cardInGraveyard.getDescription() + \"\\n\";\r\n                }\r\n            }\r\n        }\r\n        DuelView.printText(toPrint);\r\n        String input = DuelView.scan();\r\n        while (!input.equals(\"back\")) {\r\n            DuelView.printText(\"invalid command\");\r\n            input = DuelView.scan();\r\n        }\r\n    }\r\n\r\n    public void removeMonsterPlayer(int address) {\r\n        actionsOnThisCardPlayer.get(address).clear();\r\n        /*monsterZone.setHasChangedPositionInThisTurn(address, false);\r\n        monsterZone.setHasSetInThisTurn(address, false);\r\n        monsterZone.setMonsterAttackPlayer(address, null);*/\r\n        setMonsterAttackPlayer(address, null);\r\n        player.getBoard().removeMonster(address);\r\n        ((MonsterCard) selectedCard.getCard()).takeAction(this, TakeActionCase.REMOVE_FROM_MONSTERZONE, this.player, this.selectedCard.getNumber());\r\n    }\r\n\r\n    public void handleAITurn() {\r\n        setMonsterCardInAI();\r\n        changePositionInAI();\r\n        setSpellOrTrapInAI();\r\n        goNextPhase();\r\n        attackInAI();\r\n        //TODO faal sazie spell o trap\r\n        goNextPhase();\r\n        setSpellOrTrapInAI();\r\n        changeTurn();\r\n    }\r\n\r\n    //fixme un exception haye duc ro bara set monster biam inja check konam\r\n    //TODO in mokhalefe 10 haro check konam. (age na vazehe baratun ye jur null pointer e. tabe haye most or least AI ro bebinin migiri dastano)\r\n\r\n    private void setMonsterCardInAI() {\r\n        int numberOfMonstersOnPlayerBoard = numberOfMonstersOnPlayerBoard();\r\n        if (numberOfMonstersOnPlayerBoard > 1 && monsterCardWithTwoTributesWithMaxAttackPointInHand() != null)\r\n            setATwoTributeMonster();\r\n        else if (numberOfMonstersOnPlayerBoard > 0 && monsterCardWithOneTributeWithMaxAttackPointInHand() != null)\r\n            setAOneTributeMonster();\r\n        else if (numberOfMonstersOnPlayerBoard != 5 && monsterCardWithoutTributeWithMaxAttackPointInHand() != null)\r\n            setANoTributeMonster();\r\n    }\r\n\r\n    private void setATwoTributeMonster() {\r\n        if (numberOfLevelSevenEightMonstersInHand() > 0) {\r\n            this.player.getBoard().removeMonster(monsterCardWithLeaseAttackPointOnPlayerBoard());\r\n            this.player.getBoard().removeMonster(monsterCardWithLeaseAttackPointOnPlayerBoard());\r\n            this.player.getBoard().putMonster(monsterCardWithTwoTributesWithMaxAttackPointInHand(), \"OO\");\r\n        }\r\n\r\n    }\r\n\r\n    private void setAOneTributeMonster() {\r\n        if (numberOfLevelFiveSixMonstersInPlayerHand() > 0) {\r\n            this.player.getBoard().removeMonster(monsterCardWithLeaseAttackPointOnPlayerBoard());\r\n            this.player.getBoard().putMonster(monsterCardWithOneTributeWithMaxAttackPointInHand(), \"OO\");\r\n        }\r\n    }\r\n\r\n    private void setANoTributeMonster() {\r\n        if (numberOfLevelOneTwoFourMonstersInPlayerHand() > 0) {\r\n            if (monsterCardWithoutTributeWithMaxAttackPointInHand() != null && monsterCardWithLeastDefencePointOnRivalBoard() != 10)\r\n                if (numberOfMonstersOnPlayerBoard() == 0 && monsterCardWithoutTributeWithMaxAttackPointInHand().getAttack() < monsterCardWithLeaseAttackPointOnPlayerBoard())\r\n                    this.player.getBoard().putMonster(monsterCardWithMaxDefenseInHand(), \"DH\");\r\n                else if (numberOfMonstersOnPlayerBoard() < 5)\r\n                    this.player.getBoard().putMonster(monsterCardWithoutTributeWithMaxAttackPointInHand(), \"OO\");\r\n        }\r\n    }\r\n\r\n    private void setSpellOrTrapInAI() {\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof SpellCard || card instanceof TrapCard)\r\n                if (numberOfSpellsAndTrapsOnPlayerBoard() < 5)\r\n                    this.player.getBoard().putSpellOrTrap(card, \"H\");\r\n        }\r\n    }\r\n\r\n    //TODO monster ha ke set mishan unayi ke monstercard return mikonan shayad null bede!\r\n    //TODO biad bad az har bar attack alamat bezanatesh ke ta hala bahash atack zade\r\n    private void attackInAI() {\r\n        if (numberOfMonstersOnPlayerBoard() > 0) {\r\n            ArrayList<Integer> hasAttacked = new ArrayList<>();\r\n            if (numberOfMonstersOnRivalBoard() == 0)\r\n                directAttackInAI();\r\n            if (allCardsOnRivalAreDH()) {\r\n                int numberOfAttacks = minFinder(numberOfMonstersOnRivalBoard(), numberOfMonstersOnPlayerBoard());\r\n                for (int i = 0; i < numberOfAttacks; i++) {\r\n                    //TODO if already bahash attack nazade\r\n                    attackAllDHInAI();\r\n                }\r\n            }\r\n            if (monsterCardWithMostAttackPointOnPlayerBoard() != 10 && monsterCardWithMostAttackPointOnRivalBoard() != 10) {\r\n                attackOOInAI();\r\n                if (numberOfMonstersOnRivalBoard() == 0)\r\n                    directAttackInAI();\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean allCardsOnRivalAreDH() {\r\n        int counterOfDH = 0;\r\n        int counterOfCards = 0;\r\n        for (int i = 1; i < 6; i++) {\r\n            if (this.rival.getBoard().getMonsterByNumber(i) != null) {\r\n                counterOfCards++;\r\n                if (!this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"DH\"))\r\n                    counterOfDH++;\r\n            }\r\n        }\r\n        if (counterOfDH == counterOfCards)\r\n            return true;\r\n        else return false;\r\n    }\r\n\r\n    private void directAttackInAI() {\r\n        for (int i = 1; i < 6; i++) {\r\n            MonsterCard monsterCard = this.player.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null) {\r\n                try {\r\n                    selectCardPlayerMonsterZone(i);\r\n                    directAttack();\r\n                    unselectCard();\r\n                } catch (Exception exception) {\r\n                    exception.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void attackAllDHInAI() {\r\n        try {\r\n            selectCardPlayerMonsterZone(monsterCardWithMostAttackPointOnPlayerBoard());\r\n            int wantedMonster = 0;\r\n            for (int i = 1; i < 6; i++) {\r\n                MonsterCard monsterCard = this.rival.getBoard().getMonsterByNumber(i);\r\n                if (monsterCard != null) {\r\n                    wantedMonster = i;\r\n                    break;\r\n                }\r\n            }\r\n            attackMonsterDH(wantedMonster);\r\n        } catch (Exception exception) {\r\n            exception.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void attackOOInAI() {\r\n        if (this.rival.getBoard().getMonsterConditionByNumber(monsterCardWithMostAttackPointOnRivalBoard()).equals(\"OO\")) {\r\n            MonsterCard strongestRivalAttacker = this.rival.getBoard().getMonsterByNumber(monsterCardWithLeaseAttackPointOnRivalBoard());\r\n            MonsterCard strongestPlayerAttacker = this.player.getBoard().getMonsterByNumber(monsterCardWithMostAttackPointOnPlayerBoard());\r\n            if (strongestPlayerAttacker.getAttack() > strongestRivalAttacker.getAttack()) {\r\n                //TODO exception already attacked\r\n                try {\r\n                    attackMonsterOO(monsterCardWithMostAttackPointOnRivalBoard());\r\n                } catch (Exception exception) {\r\n                    exception.printStackTrace();\r\n                }\r\n            }\r\n            int indexOfSecondStrongestAttackerOnRival = monsterCardWithSecondMostAttackPointOnRivalBoard(monsterCardWithMostAttackPointOnRivalBoard());\r\n            MonsterCard secondStrongestRivalAttacker = this.rival.getBoard().getMonsterByNumber(indexOfSecondStrongestAttackerOnRival);\r\n            if (secondStrongestRivalAttacker.getAttack() < strongestPlayerAttacker.getAttack())\r\n            //fixme selectCard o in chiza ke alan vaghan halesho nadaram\r\n            {\r\n                try {\r\n                    attackMonsterOO(indexOfSecondStrongestAttackerOnRival);\r\n                } catch (Exception exception) {\r\n                    exception.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void changePositionInAI() {\r\n        MonsterCard leastAttackerOnRival = this.rival.getBoard().getMonsterByNumber(monsterCardWithLeaseAttackPointOnRivalBoard());\r\n        MonsterCard strongestAttackerOnPlayer = this.player.getBoard().getMonsterByNumber(monsterCardWithMostAttackPointOnPlayerBoard());\r\n        if (leastAttackerOnRival.getAttack() > strongestAttackerOnPlayer.getAttack()) ;\r\n        for (int i = 1; i < 6; i++) {\r\n            MonsterCard monsterCard = this.player.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null)\r\n                this.player.getBoard().changeMonsterPosition(i, \"DO\");\r\n        }\r\n    }\r\n\r\n    //varede nahie debug shodeye shaki mishavid\r\n    private MonsterCard monsterCardWithoutTributeWithMaxAttackPointInHand() {\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getLevel() < 5)\r\n                        if (((MonsterCard) card).getAttack() > maxAttackPoint) {\r\n                            maxAttackPoint = ((MonsterCard) card).getAttack();\r\n                            indexOfMaxAttacker = i;\r\n                        }\r\n            }\r\n        }\r\n        if (indexOfMaxAttacker != 10)\r\n            return this.player.getBoard().getMonsterByNumber(indexOfMaxAttacker);\r\n        else return null;\r\n    }\r\n\r\n    private MonsterCard monsterCardWithOneTributeWithMaxAttackPointInHand() {\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getLevel() == 5 || ((MonsterCard) card).getLevel() == 6)\r\n                        if (((MonsterCard) card).getAttack() > maxAttackPoint) {\r\n                            maxAttackPoint = ((MonsterCard) card).getAttack();\r\n                            indexOfMaxAttacker = i;\r\n                        }\r\n            }\r\n        }\r\n        if (indexOfMaxAttacker != 10)\r\n            return this.player.getBoard().getMonsterByNumber(indexOfMaxAttacker);\r\n        else return null;\r\n    }\r\n\r\n    private MonsterCard monsterCardWithTwoTributesWithMaxAttackPointInHand() {\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getLevel() > 6)\r\n                        if (((MonsterCard) card).getAttack() > maxAttackPoint) {\r\n                            maxAttackPoint = ((MonsterCard) card).getAttack();\r\n                            indexOfMaxAttacker = i;\r\n                        }\r\n            }\r\n        }\r\n        if (indexOfMaxAttacker != 10)\r\n            return (MonsterCard) this.player.getBoard().getCardInHandByNumber(indexOfMaxAttacker);\r\n        else return null;\r\n    }\r\n\r\n    private MonsterCard monsterCardWithMaxDefenseInHand() {\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxDefencePoint = 0;\r\n        int indexOfMaxDefender = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getDefence() > maxDefencePoint) {\r\n                        maxDefencePoint = ((MonsterCard) card).getDefence();\r\n                        indexOfMaxDefender = i;\r\n                    }\r\n            }\r\n        }\r\n        if (indexOfMaxDefender != 10)\r\n            return (MonsterCard) this.player.getBoard().getCardInHandByNumber(indexOfMaxDefender);\r\n        else return null;\r\n    }\r\n\r\n    private int monsterCardWithLeaseAttackPointOnRivalBoard() {\r\n        int leastAttackPoint = 100000;\r\n        int indexOfMinAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getSpellAndTrapConditionByNumber(i).equals(\"OO\"))\r\n                    if (leastAttackPoint > card.getAttack()) {\r\n                        indexOfMinAttacker = i;\r\n                        leastAttackPoint = card.getAttack();\r\n                    }\r\n        }\r\n        return indexOfMinAttacker;\r\n    }\r\n\r\n    private int monsterCardWithLeaseAttackPointOnPlayerBoard() {\r\n        int leastAttackPoint = 100000;\r\n        int indexOfMinAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.player.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.player.getBoard().getSpellAndTrapConditionByNumber(i).equals(\"OO\"))\r\n                    if (leastAttackPoint > card.getAttack()) {\r\n                        indexOfMinAttacker = i;\r\n                        leastAttackPoint = card.getAttack();\r\n                    }\r\n        }\r\n        return indexOfMinAttacker;\r\n    }\r\n\r\n    private int monsterCardWithSecondMostAttackPointOnRivalBoard(int indexOfStrongestAttacker) {\r\n        int indexOfSecondStrongestAttacker = 10;\r\n        int secondMostAttackPoint = 0;\r\n        if (numberOfMonstersOnPlayerBoard() > 1) {\r\n            indexOfStrongestAttacker = monsterCardWithMostAttackPointOnRivalBoard();\r\n            for (int i = 1; i <= 5; i++) {\r\n                MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n                if (card != null)\r\n                    if (i != indexOfStrongestAttacker && this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"OO\")) {\r\n                        if (secondMostAttackPoint < card.getAttack()) {\r\n                            indexOfSecondStrongestAttacker = i;\r\n                            secondMostAttackPoint = card.getAttack();\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n        return indexOfSecondStrongestAttacker;\r\n    }\r\n\r\n    private int monsterCardWithMostAttackPointOnPlayerBoard() {\r\n        int mostAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.player.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.player.getBoard().getSpellAndTrapConditionByNumber(i).equals(\"OO\"))\r\n                    if (mostAttackPoint < card.getAttack()) {\r\n                        indexOfMaxAttacker = i;\r\n                        mostAttackPoint = card.getAttack();\r\n                    }\r\n        }\r\n        return indexOfMaxAttacker;\r\n    }\r\n\r\n    private int monsterCardWithLeastDefencePointOnRivalBoard() {\r\n        int leastDefencePoint = 100000;\r\n        int indexOfMinDefender = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"DO\"))\r\n                    if (leastDefencePoint > card.getDefence()) {\r\n                        leastDefencePoint = card.getDefence();\r\n                        indexOfMinDefender = i;\r\n                    }\r\n        }\r\n        return indexOfMinDefender;\r\n    }\r\n\r\n    private int monsterCardWithMostAttackPointOnRivalBoard() {\r\n        int mostAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"OO\"))\r\n                    if (mostAttackPoint < card.getAttack()) {\r\n                        mostAttackPoint = card.getAttack();\r\n                        indexOfMaxAttacker = i;\r\n                    }\r\n        }\r\n        return indexOfMaxAttacker;\r\n    }\r\n\r\n    private int monsterCardWithMostDefencePointOnRivalBoard() {\r\n        int mostDefencePoint = 0;\r\n        int indexOfMaxDefender = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"DO\"))\r\n                    if (mostDefencePoint < card.getDefence()) {\r\n                        indexOfMaxDefender = i;\r\n                        mostDefencePoint = card.getDefence();\r\n                    }\r\n        }\r\n        return indexOfMaxDefender;\r\n    }\r\n    //payane nahie debug shode shaki\r\n\r\n    //varede nahie debug shode (be omide khoda) tazmin shode mishavid\r\n    private int numberOfMonstersOnPlayerBoard() {\r\n        int numberOfMonsters = 0;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard monsterCard = this.player.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null)\r\n                numberOfMonsters++;\r\n        }\r\n        return numberOfMonsters;\r\n    }\r\n\r\n    private int numberOfMonstersOnRivalBoard() {\r\n        int numberOfMonsters = 0;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard monsterCard = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null)\r\n                numberOfMonsters++;\r\n        }\r\n        return numberOfMonsters;\r\n    }\r\n\r\n    private int numberOfSpellsAndTrapsOnPlayerBoard() {\r\n        int numberOfSpellsAndTraps = 0;\r\n        for (int i = 1; i <= 5; i++) {\r\n            Cardable card = this.player.getBoard().getSpellAndTrapByNumber(i);\r\n            if (card != null)\r\n                numberOfSpellsAndTraps++;\r\n        }\r\n        return numberOfSpellsAndTraps;\r\n    }\r\n\r\n    private int numberOfLevelOneTwoFourMonstersInPlayerHand() {\r\n        int numberOfWantedMonsters = 0;\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof MonsterCard)\r\n                if (((MonsterCard) card).getLevel() < 5)\r\n                    numberOfWantedMonsters++;\r\n        }\r\n        return numberOfWantedMonsters;\r\n    }\r\n\r\n    private int numberOfLevelFiveSixMonstersInPlayerHand() {\r\n        int numberOfWantedMonsters = 0;\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof MonsterCard)\r\n                if (((MonsterCard) card).getLevel() == 5 || ((MonsterCard) card).getLevel() == 6)\r\n                    numberOfWantedMonsters++;\r\n        }\r\n        return numberOfWantedMonsters;\r\n    }\r\n\r\n    private int numberOfLevelSevenEightMonstersInHand() {\r\n        int numberOfWantedMonsters = 0;\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof MonsterCard)\r\n                if (((MonsterCard) card).getLevel() > 6)\r\n                    numberOfWantedMonsters++;\r\n        }\r\n        return numberOfWantedMonsters;\r\n    }\r\n    //payane nahie debug shode\r\n\r\n    public int minFinder(int firstNumber, int secondNumber) {\r\n        if (firstNumber >= secondNumber)\r\n            return secondNumber;\r\n        else return firstNumber;\r\n    }\r\n\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/controller/DuelController.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/controller/DuelController.java	(date 1624609979231)
@@ -938,7 +938,7 @@
                 }
             }
         }
-        goNextPhase();
+//        goNextPhase();
     }
 
     private void changeTurn() {
Index: src/main/java/model/User.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\nimport controller.ImportExportUserController;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\n\r\npublic class User {\r\n\r\n    private static List<User> allUsers;\r\n    private String username;\r\n    private String password;\r\n    private String nickname;\r\n    private int score;\r\n    private List<Cardable> allCards;\r\n    private List<Deck> allDecks;\r\n    private Deck currentActiveDeck;\r\n    private Deck currentGameDeck;\r\n    private int lifePoint;\r\n    private Board board;\r\n    private int money;\r\n\r\n    public User(String username, String nickname, String password) {\r\n        if (allUsers == null)\r\n            allUsers = new ArrayList<>();\r\n        this.allCards = new ArrayList<>();\r\n        this.allDecks = new ArrayList<>();\r\n        this.username = username;\r\n        this.nickname = nickname;\r\n        this.password = password;\r\n        this.currentActiveDeck = null;\r\n        setScore(0);\r\n        setMoney(100000);\r\n        allUsers.add(this);\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.exportNewUser(User.getUserByUsername(username));\r\n        importExportUserController.exportAllUsers(User.getAllUsers());\r\n    }\r\n\r\n    public Deck getGameDeck() {\r\n        return this.currentGameDeck;\r\n    }\r\n\r\n    public void setGameDeck(Deck currentGameDeck) {\r\n        this.currentGameDeck = currentGameDeck;\r\n    }\r\n\r\n    public static User getUserByUsername(String username) {\r\n        if (allUsers != null) {\r\n            for (User user : allUsers) {\r\n                if (user.getUsername().equals(username))\r\n                    return user;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public static User getUserByNickname(String nickname) {\r\n        for (User allUser : allUsers) {\r\n            if (allUser.getNickname().equals(nickname))\r\n                return allUser;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void removeDeck(Deck deck){\r\n        this.allDecks.remove(deck);\r\n    }\r\n\r\n    public void increaseScore(int amount) {\r\n        this.score += amount;\r\n    }\r\n\r\n    public void decreaseScore(int amount) {\r\n        this.score -= amount;\r\n    }\r\n\r\n    public void increaseLifePoint(int amount) {\r\n        this.lifePoint += amount;\r\n    }\r\n\r\n    public void decreaseLifePoint(int amount) {\r\n        this.lifePoint -= amount;\r\n    }\r\n\r\n    public void increaseMoney(int amount) {\r\n        this.money += amount;\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.exportNewUser(User.getUserByUsername(this.getUsername()));\r\n    }\r\n\r\n    public void decreaseMoney(int amount) {\r\n        this.money -= amount;\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.exportNewUser(User.getUserByUsername(this.getUsername()));\r\n    }\r\n\r\n    public static List<User> getAllUsers() {\r\n        return allUsers;\r\n    }\r\n\r\n    public String getUsername() {\r\n        return this.username;\r\n    }\r\n\r\n    public String getPassword() {\r\n        return this.password;\r\n    }\r\n\r\n    public String getNickname() {\r\n        return this.nickname;\r\n    }\r\n\r\n    public int getScore() {\r\n        return this.score;\r\n    }\r\n\r\n    public Deck getActiveDeck() {\r\n        return this.currentActiveDeck;\r\n    }\r\n\r\n    public Board getBoard() {\r\n        return this.board;\r\n    }\r\n\r\n    public void setNewBoard() {\r\n        this.board = new Board();\r\n    }\r\n\r\n    public int getLifePoint() {\r\n        return this.lifePoint;\r\n    }\r\n\r\n    public void setLifePoint(int lifePoint) {\r\n        this.lifePoint = lifePoint;\r\n    }\r\n\r\n    public void setScore(int score) {\r\n        this.score = score;\r\n    }\r\n\r\n    public void setMoney(int money) {\r\n        this.money = money;\r\n    }\r\n\r\n    public int getMoney() {\r\n        return this.money;\r\n    }\r\n\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.exportNewUser(User.getUserByUsername(this.getUsername()));\r\n    }\r\n\r\n    public void setNickname(String nickname) {\r\n        this.nickname = nickname;\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.exportNewUser(User.getUserByNickname(nickname));\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.exportNewUser(User.getUserByUsername(username));\r\n        importExportUserController.exportAllUsers(User.getAllUsers());\r\n    }\r\n\r\n    public void setActiveDeck(Deck deck) {\r\n        this.currentActiveDeck = deck;\r\n    }\r\n\r\n    //TODO age lazem bood jaye pascalcase aadish kon\r\n    public Cardable getCardByName(String name) {\r\n        for (Cardable card : allCards) {\r\n            if (card.getNamePascalCase().equals(name)) {\r\n                return card;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public List<Deck> getAllDecks() {\r\n        return this.allDecks;\r\n    }\r\n\r\n    public List<Cardable> getAllCards() {\r\n        return this.allCards;\r\n    }\r\n\r\n    public void deleteDeck(String name) {\r\n        this.allDecks.remove(getDeckByName(name));\r\n    }\r\n\r\n    public void deleteCard(String name) {\r\n        this.allCards.remove(getCardByName(name));\r\n    }\r\n\r\n    public void addDeck(Deck deck) {\r\n        this.allDecks.add(deck);\r\n    }\r\n\r\n    public void addCardToUsersAllCards(Cardable card) {\r\n        this.allCards.add(card);\r\n    }\r\n\r\n    public Deck getDeckByName(String name) {\r\n        for (Deck deck : allDecks) {\r\n            if (deck.getDeckName().equals(name)) {\r\n                return deck;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o){\r\n        User user = (User) o;\r\n        return  (this.username.equals(user.username));\r\n    }\r\n\r\n//    @Override\r\n//    public boolean equals(Object o) {\r\n//        if (this == o) return true;\r\n//        if (o == null || getClass() != o.getClass()) return false;\r\n//        User user = (User) o;\r\n//        return Objects.equals(this.username, user.username);\r\n//    }\r\n\r\n\r\n//    @Override\r\n//    public boolean equals(Object o) {\r\n//        if (this == o) return true;\r\n//        if (o == null || getClass() != o.getClass()) return false;\r\n//        User user = (User) o;\r\n//        return Objects.equals(username, user.username);\r\n//    }\r\n//\r\n//    @Override\r\n//    public int hashCode() {\r\n//        return Objects.hash(username);\r\n//    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/model/User.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/model/User.java	(date 1624608162191)
@@ -91,6 +91,7 @@
     }
 
     public void decreaseMoney(int amount) {
+        //TODO put back
         this.money -= amount;
         ImportExportUserController importExportUserController = ImportExportUserController.getInstance();
         importExportUserController.exportNewUser(User.getUserByUsername(this.getUsername()));
@@ -139,7 +140,7 @@
     public void setScore(int score) {
         this.score = score;
     }
-
+    //TODO put back
     public void setMoney(int money) {
         this.money = money;
     }
@@ -220,25 +221,25 @@
         return  (this.username.equals(user.username));
     }
 
-//    @Override
-//    public boolean equals(Object o) {
-//        if (this == o) return true;
-//        if (o == null || getClass() != o.getClass()) return false;
-//        User user = (User) o;
-//        return Objects.equals(this.username, user.username);
-//    }
+/*    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        User user = (User) o;
+        return Objects.equals(this.username, user.username);
+    }
 
 
-//    @Override
-//    public boolean equals(Object o) {
-//        if (this == o) return true;
-//        if (o == null || getClass() != o.getClass()) return false;
-//        User user = (User) o;
-//        return Objects.equals(username, user.username);
-//    }
-//
-//    @Override
-//    public int hashCode() {
-//        return Objects.hash(username);
-//    }
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        User user = (User) o;
+        return Objects.equals(username, user.username);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(username);
+    }*/
 }
Index: src/main/java/controller/DeckController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport controller.exeption.*;\r\nimport model.*;\r\nimport view.*;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\n\r\npublic class DeckController {\r\n    private static DeckController instance = null;\r\n    private User user;\r\n\r\n    public static DeckController getInstance(User user) {\r\n        if (instance == null) instance = new DeckController(user);\r\n        else if (!instance.user.equals(user)) instance.user = user;\r\n        return instance;\r\n    }\r\n\r\n    public List<Cardable> getAllCardsOfGame(){\r\n        List<Cardable> allCards = new ArrayList<>();\r\n        Collections.addAll(allCards, MonsterCard.values());\r\n        Collections.addAll(allCards, TrapCard.values());\r\n        Collections.addAll(allCards, SpellCard.values());\r\n        Comparator<Cardable> cardComparator = Comparator.comparing(Cardable::getName);\r\n        allCards.sort(cardComparator);\r\n        return allCards;\r\n    }\r\n\r\n    public Cardable getCardByName(String name){\r\n        List<Cardable> allCards = getAllCardsOfGame();\r\n        for (Cardable card : allCards) {\r\n            if (card.getNamePascalCase().equals(name))\r\n                return card;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private DeckController(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public void createDeck(String name) throws Exception {\r\n        if (this.user.getDeckByName(name) == null) {\r\n            Deck deck = new Deck(name);\r\n            this.user.addDeck(deck);\r\n            ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n            importExportUserController.exportAllDecksName(this.user.getAllDecks(),this.user);\r\n            DeckView.getInstance(this.user).printText(\"deck created successfully!\");\r\n        } else {\r\n            throw new RepetitiveDeckName(name);\r\n        }\r\n    }\r\n\r\n    public Deck createRandomDeckForAI(){\r\n        Deck deck = new Deck(\"DeckForAI\");\r\n        List<Cardable> allCards = new ArrayList<>();\r\n        Collections.addAll(allCards, MonsterCard.values());\r\n        Collections.addAll(allCards, SpellCard.values());\r\n        Collections.addAll(allCards, TrapCard.values());\r\n\r\n        while (user.getDeckByName(\"DeckForAI\").getMainSize() < 46){\r\n            int randomNum = ThreadLocalRandom.current().nextInt(0, allCards.size());\r\n            try {\r\n                addCardToDeck(allCards.get(randomNum).getName(),\"DeckForAi\",false,false);\r\n            } catch (Exception exception) {\r\n                exception.printStackTrace();\r\n            }\r\n        }\r\n        return deck;\r\n    }\r\n\r\n    public void deleteDeck(String name) throws Exception {\r\n        if (this.user.getDeckByName(name) != null) {\r\n            this.user.deleteDeck(name);\r\n            ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n            importExportUserController.exportAllDecksName(this.user.getAllDecks(),this.user);\r\n            DeckView.getInstance(this.user).printText(\"deck deleted successfully\");\r\n        } else\r\n            throw new DeckNotFound(name);\r\n    }\r\n\r\n    public void addCardToDeck(String cardName, String deckName, boolean isSide, boolean isAddedByCheating) throws Exception {\r\n        Cardable card = this.user.getCardByName(cardName);\r\n        if (card != null) {\r\n            Deck deck = this.user.getDeckByName(deckName);\r\n            if (deck != null) {\r\n                if (!isAddedByCheating) {\r\n                    if (isSide && deck.getSideSize() >= 15)\r\n                        throw new FullSideDeck();\r\n                    else if (!(isSide) && (deck.getMainSize() >= 60))\r\n                        throw new FullMainDeck();\r\n                }\r\n                if ((card instanceof MonsterCard ||\r\n                        (card instanceof SpellCard && ((SpellCard) card).getStatus().equals(Status.UNLIMITED))\r\n                        || (card instanceof TrapCard && ((TrapCard) card).getStatus().equals(Status.UNLIMITED)))\r\n                        && deck.numberOfWantedCard(card) == 3)\r\n                    throw new ThreeSameCards(cardName, deckName);\r\n                else if (((card instanceof SpellCard && ((SpellCard) card).getStatus().equals(Status.LIMITED))\r\n                        || (card instanceof TrapCard && ((TrapCard) card).getStatus().equals(Status.LIMITED)))\r\n                        && deck.numberOfWantedCard(card) == 1)\r\n                    throw new OneCardForLimited(cardName, deckName);\r\n                else {\r\n                    if (isSide) {\r\n                        deck.addCardToSideDeck(card);\r\n                        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n                        importExportUserController.exportCardsInSideDeck(this.user,deckName);\r\n                    } else {\r\n                        deck.addCardToMainDeck(card);\r\n                        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n                        importExportUserController.exportCardsInMainDeck(this.user,deckName);\r\n                    }\r\n                    this.user.deleteCard(cardName);\r\n                    DeckView.getInstance(this.user).printText(\"card added to deck successfully\");\r\n                }\r\n            } else throw new DeckNotFound(deckName);\r\n        } else throw new CardNotFoundInUser(cardName);\r\n    }\r\n\r\n    public void activateDeck(String name) throws Exception {\r\n        if (this.user.getDeckByName(name) != null) {\r\n            this.user.setActiveDeck(this.user.getDeckByName(name));\r\n            DeckView.getInstance(this.user).printText(\"deck activated successfully\");\r\n        } else\r\n            throw new DeckNotFound(name);\r\n    }\r\n\r\n    public void removeCardFromDeck(String cardName, String deckName, boolean isSide) throws Exception {\r\n        Deck deck = user.getDeckByName(deckName);\r\n        if (deck != null) {\r\n            Cardable card = DeckController.getInstance(user).getCardByName(cardName);\r\n            if (card != null) {\r\n                if (isSide) {\r\n                    if (deck.cardExistsInDeck(card, true)) {\r\n                        deck.removeCardFromSideDeck(card);\r\n                        this.user.addCardToUsersAllCards(card);\r\n                        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n                        importExportUserController.exportCardsInSideDeck(this.user,deckName);\r\n                        importExportUserController.exportAllCards(this.user);\r\n                        DeckView.getInstance(user).printText(\"card removed form deck successfully\");\r\n                    } else throw new CardNotFoundInDeck(cardName, \"side\");\r\n                } else {\r\n                    if (deck.cardExistsInDeck(card, false)) {\r\n                        deck.removeCardFromMainDeck(card);\r\n                        this.user.addCardToUsersAllCards(card);\r\n                        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n                        importExportUserController.exportCardsInMainDeck(this.user,deckName);\r\n                        importExportUserController.exportAllCards(this.user);\r\n                        DeckView.getInstance(user).printText(\"card removed form deck successfully\");\r\n                    } else throw new CardNotFoundInDeck(cardName, \"main\");\r\n                }\r\n            } else\r\n                throw new CardNotFoundForController();\r\n        } else\r\n            throw new DeckNotFound(deckName);\r\n    }\r\n\r\n    public void showAllDecks() {\r\n        StringBuilder toPrint = new StringBuilder(\"Decks:\\nActive deck:\\n\");\r\n        List<Deck> allDecks = new ArrayList<>(this.user.getAllDecks());\r\n        Deck activeDeck = null;\r\n        if (this.user.getActiveDeck() != null) {\r\n        for (Deck deck : allDecks) {\r\n                if (this.user.getActiveDeck().getDeckName().equals(deck.getDeckName())) {\r\n                        toPrint.append(deck.toString());\r\n                        if (deck.isValid()) toPrint.append(\", valid\\n\");\r\n                        else toPrint.append(\", invalid\\n\");\r\n                        activeDeck = deck;\r\n                }\r\n            }\r\n        }\r\n\r\n        toPrint.append(\"Other decks:\\n\");\r\n        allDecks.remove(activeDeck);\r\n        Comparator<Deck> deckComparator = Comparator.comparing(Deck::getDeckName);\r\n        allDecks.sort(deckComparator);\r\n        for (Deck deck : allDecks) {\r\n            toPrint.append(deck.toString());\r\n            if (allDecks.get(allDecks.size() - 1).equals(deck)) {\r\n                if (deck.isValid()) toPrint.append(\", valid\");\r\n                else toPrint.append(\", invalid\");\r\n            } else {\r\n                if (deck.isValid()) toPrint.append(\", valid\\n\");\r\n                else toPrint.append(\", invalid\\n\");\r\n            }\r\n        }\r\n        DeckView.getInstance(this.user).printText(toPrint.toString());\r\n    }\r\n\r\n    public void showDeck(String deckName, boolean isSide) throws Exception {\r\n        if (this.user.getDeckByName(deckName) == null) throw new DeckNotFound(deckName);\r\n        String toPrint = \"Deck: \" + deckName + \"\\n\";\r\n        if (isSide) toPrint += \"Side deck:\\nMonsters:\\n\";\r\n        else toPrint += \"Main deck:\\nMonsters:\\n\";\r\n        ArrayList<Cardable> monsterCards = new ArrayList<>();\r\n        ArrayList<Cardable> spellAndTrapCards = new ArrayList<>();\r\n        if (!isSide) {\r\n            for (Cardable eachCard : this.user.getDeckByName(deckName).getMainDeck()) {\r\n                if (eachCard instanceof MonsterCard) monsterCards.add(eachCard);\r\n                else spellAndTrapCards.add(eachCard);\r\n            }\r\n        } else {\r\n            for (Cardable eachCard : this.user.getDeckByName(deckName).getSideDeck()) {\r\n                if (eachCard instanceof MonsterCard) monsterCards.add(eachCard);\r\n                else spellAndTrapCards.add(eachCard);\r\n            }\r\n        }\r\n        Comparator<Cardable> cardComparator = Comparator.comparing(Cardable::getNamePascalCase);\r\n        monsterCards.sort(cardComparator);\r\n        spellAndTrapCards.sort(cardComparator);\r\n        for (Cardable eachCard : monsterCards) {\r\n            toPrint += eachCard.getNamePascalCase() + \":\" + eachCard.getDescription() + \"\\n\";\r\n        }\r\n        toPrint += \"Spell and Traps:\";\r\n        for (Cardable eachCard : spellAndTrapCards) {\r\n            toPrint += \"\\n\" + eachCard.getNamePascalCase() + \":\" + eachCard.getDescription();\r\n        }\r\n        DeckView.getInstance(this.user).printText(toPrint);\r\n//        return toPrint;\r\n    }\r\n\r\n    public void showAllCards() {\r\n        String toPrint = \"\";\r\n        List<Cardable> allCards = this.user.getAllCards();\r\n        Comparator<Cardable> cardComparator = Comparator.comparing(Cardable::getNamePascalCase);\r\n        allCards.sort(cardComparator);\r\n        for (Cardable card : allCards) {\r\n            toPrint += card.getNamePascalCase() + \":\" + card.getDescription() + \"\\n\";\r\n        }\r\n        DeckView.getInstance(this.user).printText(toPrint);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/controller/DeckController.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/controller/DeckController.java	(date 1624609355856)
@@ -47,6 +47,8 @@
         if (this.user.getDeckByName(name) == null) {
             Deck deck = new Deck(name);
             this.user.addDeck(deck);
+            //TODO remove this
+            System.out.println("deck created!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
             ImportExportUserController importExportUserController = ImportExportUserController.getInstance();
             importExportUserController.exportAllDecksName(this.user.getAllDecks(),this.user);
             DeckView.getInstance(this.user).printText("deck created successfully!");
@@ -61,7 +63,6 @@
         Collections.addAll(allCards, MonsterCard.values());
         Collections.addAll(allCards, SpellCard.values());
         Collections.addAll(allCards, TrapCard.values());
-
         while (user.getDeckByName("DeckForAI").getMainSize() < 46){
             int randomNum = ThreadLocalRandom.current().nextInt(0, allCards.size());
             try {
Index: .idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM__Default_Changelist_.xml
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM__Default_Changelist_.xml	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM__Default_Changelist_.xml	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM_[Default_Changelist]" date="1624001993483" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM_[Default_Changelist]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 6/18/2021 12:08 PM [Default Changelist]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM_[Default_Changelist]/shelved.patch
===================================================================
--- .idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM_[Default_Changelist]/shelved.patch	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ .idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM_[Default_Changelist]/shelved.patch	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
@@ -1,204 +0,0 @@
-Index: src/main/java/model/TakeActionCase.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package model;\r\n\r\npublic enum TakeActionCase {\r\n    SUMMONED,\r\n    REMOVE_FROM_MONSTERZONE,\r\n    ATTACKED,\r\n    FLIP_SUMMONED,\r\n    SPECIAL_SUMMONED,\r\n    DIED_BY_BEING_ATTACKED,\r\n    PUT_IN_MONSTERZONE,\r\n    PUT_IN_SPELLTRAPZONE,\r\n    REMOVE_FROM_SPELLTRAPZONE,\r\n    TURN_START;\r\n//    RITUAL_SUMMONED\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/model/TakeActionCase.java	(revision 7f7108b19f275a68ca32b60240f17cc8f3739458)
-+++ src/main/java/model/TakeActionCase.java	(date 1624001818812)
-@@ -10,6 +10,8 @@
-     PUT_IN_MONSTERZONE,
-     PUT_IN_SPELLTRAPZONE,
-     REMOVE_FROM_SPELLTRAPZONE,
-+    PUT_IN_FIELDZONE_FACE_UP,
-+    REMOVE_FROM_FIELDZONE_FACE_UP,
-     TURN_START;
- //    RITUAL_SUMMONED
- }
-Index: src/main/java/controller/DuelController.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package controller;\r\n\r\nimport controller.exeption.*;\r\nimport model.*;\r\nimport view.DuelView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\npublic class DuelController {\r\n\r\n    public static final int[] playerGroundNumbers = {3, 4, 2, 5, 1};\r\n    public static final int[] opponentGroundNumbers = {3, 2, 4, 1, 5};\r\n    private User player;\r\n    private User rival;\r\n    private Round[] rounds;\r\n    private final int roundNumber;\r\n    private SelectedCard selectedCard;\r\n    private int roundCounter;\r\n    private Phase phase;\r\n    private boolean hasSummonedOrSetInThisTurn;\r\n    private ArrayList<ArrayList<ActionsDoneInTurn>> actionsOnThisCardPlayer=new ArrayList<>(5);\r\n//    private ArrayList<ArrayList<ActionsDoneInTurn>> actionsOnThisCardRival=new ArrayList<>(5);\r\n    private Integer[] playerAttackPoints;\r\n    private Integer[] rivalAttackPoints;\r\n    /*private boolean hasUsedHeraldInThisTurn;\r\n    private boolean hasUsedTexChangerInThisTurn;*/\r\n    /*boolean[] hasChangedPositionInThisTurn;\r\n    boolean[] hasSetInThisTurn;\r\n    boolean[] hasAttackedInThisTurn;*/\r\n//    MonsterZone monsterZone;\r\n    boolean isStartTurn;\r\n    private boolean shouldEndGameForView;\r\n    //TODO check frequently: cancel, unselect, printBoard\r\n\r\n    public DuelController(User player, User rival, int roundNumber) {\r\n        this.player = player;\r\n        this.rival = rival;\r\n        setGameDeck(this.player);\r\n        setGameDeck(this.rival);\r\n        this.rounds = new Round[roundNumber];\r\n        this.roundNumber = roundNumber;\r\n        this.roundCounter = 0;\r\n//        this.monsterZone = new MonsterZone(this);\r\n        startNewGame(null);\r\n    }\r\n\r\n    private void setGameDeck(User user) {\r\n        Deck deck;\r\n        if (user.getDeckByName(\"@\" + user.getActiveDeck().getDeckName()) == null) {\r\n            deck = new Deck(\"@\" + user.getActiveDeck().getDeckName());\r\n        } else {\r\n            deck = user.getDeckByName(\"@\" + user.getActiveDeck().getDeckName());\r\n            user.removeDeck(deck);\r\n        }\r\n        ArrayList<Cardable> mainCards = new ArrayList<>(user.getActiveDeck().getMainDeck());\r\n        ArrayList<Cardable> sideCards = new ArrayList<>(user.getActiveDeck().getSideDeck());\r\n        deck.setDeck(mainCards, sideCards);\r\n        user.addDeck(deck);\r\n        user.setGameDeck(deck);\r\n    }\r\n\r\n    public User getPlayer() {\r\n        return this.player;\r\n    }\r\n\r\n    public User getRival() {\r\n        return this.rival;\r\n    }\r\n\r\n    public void setPlayer(User player) {\r\n        this.player = player;\r\n    }\r\n\r\n    public void setRival(User rival) {\r\n        this.rival = rival;\r\n    }\r\n\r\n    public boolean getHasEnabledSuijin(int i){\r\n        return actionsOnThisCardPlayer.get(i).contains(ActionsDoneInTurn.ENABLE_SUIJIN);\r\n    }\r\n\r\n    public void setHasEnabledSuijinTrue(int i){\r\n        actionsOnThisCardPlayer.get(i).add(ActionsDoneInTurn.ENABLE_SUIJIN);\r\n    }\r\n\r\n    public void setMonsterAttackPlayer(int i,Integer number){\r\n        this.playerAttackPoints[i] = number;\r\n    }\r\n\r\n    public void setMonsterAttackRival(int i,Integer number){\r\n        this.rivalAttackPoints[i] = number;\r\n    }\r\n\r\n    /*public MonsterZone getMonsterZone() {\r\n        return this.monsterZone;\r\n    }*/\r\n\r\n    public SelectedCard getSelectedCard() {\r\n        return this.selectedCard;\r\n    }\r\n\r\n    public boolean getShouldEndGameForView() {\r\n        return this.shouldEndGameForView;\r\n    }\r\n\r\n    public static int[] getOpponentGroundNumbers() {\r\n        return opponentGroundNumbers;\r\n    }\r\n\r\n    public static int[] getPlayerGroundNumbers() {\r\n        return playerGroundNumbers;\r\n    }\r\n\r\n\r\n    /*public boolean getHasUsedHeraldInThisTurn() {\r\n        return this.hasUsedHeraldInThisTurn;\r\n    }\r\n\r\n    public void setHasHasUsedHeraldInThisTurnTrue() {\r\n        this.hasUsedHeraldInThisTurn = true;\r\n    }\r\n\r\n    public boolean getHasUsedTexChangerInThisTurn() {\r\n        return this.hasUsedTexChangerInThisTurn;\r\n    }\r\n\r\n    public void setHasUsedTexChangerInThisTurn() {\r\n        this.hasUsedTexChangerInThisTurn = true;\r\n    }*/\r\n\r\n    //TODO age vaght shod choose first player random\r\n    private void startNewGame(User winner) {\r\n        if (winner != null) {\r\n            User loser;\r\n            if (winner.equals(this.player)) {\r\n                loser = this.rival;\r\n            } else {\r\n                loser = this.player;\r\n            }\r\n            this.player = loser;\r\n            this.rival = winner;\r\n        } else this.isStartTurn = true;\r\n        this.player.setNewBoard();\r\n        this.rival.setNewBoard();\r\n        clearLastTurn();\r\n        startDrawPhase(true);\r\n    }\r\n\r\n    public void selectCardPlayerMonsterZone(int address) throws Exception {\r\n        MonsterCard[] monsters = this.player.getBoard().getMonsters();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (monsters[address] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.player.getBoard().getMonsterByNumber(address), BoardZone.MONSTERZONE, address, this.player);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardOpponentMonsterZone(int address) throws Exception {\r\n        MonsterCard[] monsters = this.rival.getBoard().getMonsters();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = opponentGroundNumbers[address - 1] - 1;\r\n        if (monsters[address - 1] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.rival.getBoard().getMonsterByNumber(address), BoardZone.MONSTERZONE, address, this.rival);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardPlayerTrapAndSpellZone(int address) throws Exception {\r\n        Cardable[] spellAndTrap = this.player.getBoard().getSpellsAndTraps();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (spellAndTrap[address - 1] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.player.getBoard().getSpellAndTrapByNumber(address), BoardZone.SPELLANDTRAPZONE, address, this.player);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardOpponentTrapAndSpellZone(int address) throws Exception {\r\n        Cardable[] spellAndTrap = this.rival.getBoard().getSpellsAndTraps();\r\n        if ((address > 5) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        }\r\n        address = opponentGroundNumbers[address - 1] - 1;\r\n        if (spellAndTrap[address - 1] == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.rival.getBoard().getSpellAndTrapByNumber(address), BoardZone.SPELLANDTRAPZONE, address, this.rival);\r\n\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardPlayerFieldZone() throws Exception {\r\n        Cardable fieldZone = this.player.getBoard().getFieldZone();\r\n        if (fieldZone == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.player.getBoard().getFieldZone(), BoardZone.FIELDZONE, 1, this.player);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardOpponentFieldZone() throws Exception {\r\n        Cardable fieldZone = this.player.getBoard().getFieldZone();\r\n        if (fieldZone == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        } else {\r\n            this.selectedCard = new SelectedCard(this.rival.getBoard().getFieldZone(), BoardZone.FIELDZONE, 1, this.rival);\r\n            DuelView.printText(\"card selected\");\r\n        }\r\n    }\r\n\r\n    public void selectCardPlayerHand(int address) throws Exception {\r\n        List<Cardable> cardsInHand = this.player.getBoard().getCardsInHand();\r\n        if ((address > cardsInHand.size()) || (address < 1)) {\r\n            throw new InvalidSelection();\r\n        } else if (cardsInHand.get(address - 1) == null) {\r\n            throw new NoCardFoundInThisPosition();\r\n        }\r\n        this.selectedCard = new SelectedCard(this.player.getBoard().getCardInHandByNumber(address - 1), BoardZone.HAND, address - 1, this.player);\r\n        DuelView.printText(\"card selected\");\r\n    }\r\n\r\n    private void unselectCard() throws Exception {\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        } else {\r\n            this.selectedCard = null;\r\n        }\r\n    }\r\n\r\n    public void setSelectedCard(SelectedCard selectedCard) {\r\n        this.selectedCard = selectedCard;\r\n    }\r\n\r\n    public void unselectCardFromCommand() throws Exception {\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        } else {\r\n            this.selectedCard = null;\r\n            DuelView.printText(\"card deselected\");\r\n        }\r\n    }\r\n\r\n    public int getCountOfMonsterCardsInGround(User user) {\r\n        MonsterCard[] monsterCards = user.getBoard().getMonsters();\r\n        int countOfMonsterCardsInGround = 0;\r\n        for (int i = 0; i < 5; i++) {\r\n            if (monsterCards[i] != null) {\r\n                countOfMonsterCardsInGround++;\r\n            }\r\n        }\r\n        return countOfMonsterCardsInGround;\r\n    }\r\n\r\n    public void summonMonster() throws Exception {\r\n        //TODO special va ritual summon\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        }\r\n        //TODO in exception payinie halate \"مد نظر قابلیت احضار عادی را نداشته باشد monster\" ro nadare hanooz(fekr konam dare alan)\r\n        if (!(this.selectedCard.getCard() instanceof MonsterCard && this.selectedCard.getBoardZone().equals(BoardZone.HAND) && !((MonsterCard) this.selectedCard.getCard()).getCardType().equals(CardType.RITUAL))) {\r\n            throw new CanNotSummon();\r\n        }\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2)))) {\r\n            throw new ActionNotAllowedInThisPhase();\r\n        }\r\n        if (this.player.getBoard().isFullMonsterZone()) {\r\n            throw new FullMonsterZone();\r\n        }\r\n        if (((MonsterCard) this.selectedCard.getCard()).getCanBeNormalSummoned()) {\r\n            if (hasSummonedOrSetInThisTurn) {\r\n                throw new AlreadySummoned();\r\n            }\r\n            MonsterCard monsterCard = (MonsterCard) selectedCard.getCard();\r\n            if (monsterCard.getLevel() <= 4) {\r\n                this.player.getBoard().putMonster(monsterCard, \"OO\");\r\n                monsterCard.takeAction(this, TakeActionCase.SUMMONED, this.player, this.selectedCard.getNumber());\r\n                this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n                unselectCard();\r\n                DuelView.printText(\"summoned successfully\");\r\n                hasSummonedOrSetInThisTurn = true;\r\n                return;\r\n            }\r\n            if (monsterCard.getLevel() < 7) {\r\n                if (getCountOfMonsterCardsInGround(this.player) < 1) {\r\n                    throw new InsufficientForTribute();\r\n                } else {\r\n                    tributeOneMonsterForSummon();\r\n                }\r\n            } else {\r\n                if (getCountOfMonsterCardsInGround(this.player) < 2) {\r\n                    throw new InsufficientForTribute();\r\n                } else {\r\n                    tributeTwoMonstersForSummon();\r\n                }\r\n            }\r\n        } else if (!((MonsterCard) this.selectedCard.getCard()).getCardType().equals(CardType.RITUAL)) {\r\n            specialSummonNormal();\r\n        }\r\n    }\r\n\r\n    private void tributeOneMonsterForSummon() throws Exception {\r\n        String input = DuelView.scan();\r\n        if (input.equals(\"cancel\")) return;\r\n        int address = Integer.parseInt(input);\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address) == null) throw new NoMonsterHere1();\r\n        this.player.getBoard().removeMonster(address);\r\n        removeMonsterPlayer(address);\r\n        this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"OO\");\r\n        ((MonsterCard) selectedCard.getCard()).takeAction(this, TakeActionCase.SUMMONED, this.player, this.selectedCard.getNumber());\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"summoned successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n    }\r\n\r\n    private void tributeTwoMonstersForSummon() throws Exception {\r\n        String input1 = DuelView.scan();\r\n        if (input1.equals(\"cancel\")) return;\r\n        int address1 = Integer.parseInt(input1) - 1;\r\n        address1 = playerGroundNumbers[address1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address1) == null) throw new NoMonsterHere1();\r\n        String input2 = DuelView.scan();\r\n        if (input2.equals(\"cancel\")) return;\r\n        int address2 = Integer.parseInt(input2) - 1;\r\n        address2 = playerGroundNumbers[address2] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address2) == null) throw new NoMonsterHere1();\r\n        if (address1 == address2) throw new sameAddresses();\r\n        this.player.getBoard().removeMonster(address1);\r\n        this.player.getBoard().removeMonster(address2);\r\n        removeMonsterPlayer(address1);\r\n        removeMonsterPlayer(address2);\r\n        this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"OO\");\r\n        ((MonsterCard) selectedCard.getCard()).takeAction(this, TakeActionCase.SUMMONED, this.player, this.selectedCard.getNumber());\r\n        this.player.getBoard().getCardsInHand().remove((int) this.selectedCard.getNumber());\r\n        unselectCard();\r\n        DuelView.printText(\"summoned successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n    }\r\n\r\n    public void specialSummonNormal() throws Exception {\r\n        ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.SPECIAL_SUMMONED, this.player, this.selectedCard.getNumber());\r\n\r\n    }\r\n\r\n    private void specialSummonWithSpell() throws Exception {\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.HAND)) {\r\n            throw new CanNotSpecialSummon();\r\n        }\r\n        /*if (*//*hayula special summon nashod*//*) {\r\n        DuelView.printText(\"you should special summon right now\");\r\n        special summon kone\r\n        }*/\r\n    }\r\n\r\n    public void preSet() throws Exception {\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!(this.selectedCard.getBoardZone().equals(BoardZone.HAND))) throw new CanNotSet();\r\n        if (this.selectedCard.getCard() instanceof MonsterCard) setMonster();\r\n        else if (this.selectedCard.getCard() instanceof SpellCard) setSpell();\r\n        else if (this.selectedCard.getCard() instanceof TrapCard) setTrap();\r\n    }\r\n\r\n    private void setMonster() throws Exception {\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2)))) {\r\n            throw new ImproperPhase();\r\n        }\r\n        if (this.player.getBoard().isFullMonsterZone()) {\r\n            throw new FullMonsterZone();\r\n        }\r\n        if (hasSummonedOrSetInThisTurn) {\r\n            throw new AlreadySummoned();\r\n        }\r\n        MonsterCard monsterCard = (MonsterCard) this.selectedCard.getCard();\r\n        if (monsterCard.getLevel() <= 4) {\r\n            this.actionsOnThisCardPlayer.get(this.player.getBoard().putMonster(monsterCard, \"DH\")).add(ActionsDoneInTurn.SET);\r\n//            monsterZone.setHasSetInThisTurn(this.player.getBoard().putMonster(monsterCard, \"DH\"), true);\r\n            this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n            unselectCard();\r\n            DuelView.printText(\"set successfully\");\r\n            hasSummonedOrSetInThisTurn = true;\r\n            printBoard();\r\n            return;\r\n        }\r\n        if (monsterCard.getLevel() < 7) {\r\n            if (getCountOfMonsterCardsInGround(this.player) < 1) {\r\n                throw new InsufficientForTribute();\r\n            } else {\r\n                tributeOneMonsterForSet();\r\n            }\r\n        } else {\r\n            if (getCountOfMonsterCardsInGround(this.player) < 2) {\r\n                throw new InsufficientForTribute();\r\n            } else {\r\n                tributeTwoMonstersForSet();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void tributeOneMonsterForSet() throws Exception {\r\n        String input = DuelView.scan();\r\n        if (input.equals(\"cancel\")) return;\r\n        int address = Integer.parseInt(input);\r\n        address = playerGroundNumbers[address - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address) == null) throw new NoMonsterHere1();\r\n        this.player.getBoard().removeMonster(address);\r\n        removeMonsterPlayer(address);\r\n        this.actionsOnThisCardPlayer.get(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\")).add(ActionsDoneInTurn.SET);\r\n//        monsterZone.setHasSetInThisTurn(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\"), true);\r\n        this.player.getBoard().getCardsInHand().remove((int) this.selectedCard.getNumber());\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n        printBoard();\r\n    }\r\n\r\n    private void tributeTwoMonstersForSet() throws Exception {\r\n        String input1 = DuelView.scan();\r\n        if (input1.equals(\"cancel\")) return;\r\n        int address1 = Integer.parseInt(input1);\r\n        address1 = playerGroundNumbers[address1 - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address1) == null) throw new NoMonsterHere1();\r\n        String input2 = DuelView.scan();\r\n        if (input2.equals(\"cancel\")) return;\r\n        int address2 = Integer.parseInt(input2);\r\n        address2 = playerGroundNumbers[address2 - 1] - 1;\r\n        if (this.player.getBoard().getMonsterByNumber(address2) == null) throw new NoMonsterHere1();\r\n        if (address1 == address2) throw new sameAddresses();\r\n        this.player.getBoard().getCardsInHand().remove((int) this.selectedCard.getNumber());\r\n        this.player.getBoard().removeMonster(address1);\r\n        this.player.getBoard().removeMonster(address2);\r\n        removeMonsterPlayer(address1);\r\n        removeMonsterPlayer(address2);\r\n        this.actionsOnThisCardPlayer.get(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\")).add(ActionsDoneInTurn.SET);\r\n//        monsterZone.setHasSetInThisTurn(this.player.getBoard().putMonster((MonsterCard) selectedCard.getCard(), \"DH\"), true);\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        hasSummonedOrSetInThisTurn = true;\r\n        printBoard();\r\n    }\r\n\r\n    private void setSpell() throws Exception {\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new ImproperPhase();\r\n        SpellCard spellCard = (SpellCard) this.selectedCard.getCard();\r\n        if (!spellCard.getIcon().equals(Icon.FIELD)) {\r\n            if (this.player.getBoard().isFullSpellAndTrapZone())\r\n                throw new FullSpellZone();\r\n            this.player.getBoard().putSpellOrTrap(spellCard, \"H\");\r\n        } else {\r\n            if (this.player.getBoard().getFieldZone() != null) {\r\n                this.player.getBoard().putInGraveYard(this.player.getBoard().getFieldZone());\r\n                this.player.getBoard().removeFromFieldZone();\r\n            }\r\n            this.player.getBoard().putInFieldZone(spellCard);\r\n        }\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    private void setTrap() throws Exception {\r\n        if (!(phase.equals(Phase.MAIN_PHASE1) || (phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new ImproperPhase();\r\n        TrapCard trapCard = (TrapCard) this.selectedCard.getCard();\r\n        if (!trapCard.getIcon().equals(Icon.FIELD)) {\r\n            if (this.player.getBoard().isFullSpellAndTrapZone()) {\r\n                throw new FullSpellZone();\r\n            }\r\n            this.player.getBoard().putSpellOrTrap(trapCard, \"H\");\r\n        } else {\r\n            if (this.player.getBoard().getFieldZone() != null) {\r\n                this.player.getBoard().putInGraveYard(this.player.getBoard().getFieldZone());\r\n                this.player.getBoard().removeFromFieldZone();\r\n            }\r\n            this.player.getBoard().putInFieldZone(trapCard);\r\n        }\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"set successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    public void changePosition(String targetPosition) throws Exception {\r\n        String targetPositionInShort = \"\";\r\n        switch (targetPosition) {\r\n            case \"attack\":\r\n                targetPositionInShort = \"OO\";\r\n                break;\r\n            case \"defence\":\r\n                targetPositionInShort = \"DO\";\r\n                break;\r\n        }\r\n        if (this.selectedCard == null)\r\n            throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE) || this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"DH\"))\r\n            throw new CanNotChangePosition();\r\n        if (!(this.phase.equals(Phase.MAIN_PHASE1) || (this.phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new CantDoActionInThisPhase();\r\n        if (this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(targetPositionInShort) || this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"DH\"))\r\n            throw new AlreadyInWantedPosition();\r\n        if (actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.CHANGE_POSITION))\r\n            throw new AlreadyChangedPosition();\r\n        if (actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.ATTACK) && this.phase.equals(Phase.MAIN_PHASE2))\r\n            throw new HasAttackedInBattle();\r\n        this.player.getBoard().changeMonsterPosition(this.selectedCard.getNumber(), targetPositionInShort);\r\n        actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.CHANGE_POSITION);\r\n//        monsterZone.setHasChangedPositionInThisTurn(this.selectedCard.getNumber(), true);\r\n        DuelView.printText(\"monster card position changed successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    public void flipSummon() throws Exception {\r\n        if (this.selectedCard == null)\r\n            throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE))\r\n            throw new CanNotChangePosition();\r\n        if (!(this.phase.equals(Phase.MAIN_PHASE1) || this.phase.equals(Phase.MAIN_PHASE2)))\r\n            throw new CantDoActionInThisPhase();\r\n        if (!this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"DH\") || actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.SET))\r\n            throw new CanNotFlipSummon();\r\n        this.player.getBoard().changeMonsterPosition(this.selectedCard.getNumber(), \"OO\");\r\n        ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.FLIP_SUMMONED, this.player, this.selectedCard.getNumber());\r\n        unselectCard();\r\n        DuelView.printText(\"flip summoned successfully\");\r\n        printBoard();\r\n    }\r\n\r\n    public void attackMonster(int monsterNumber) throws Exception {\r\n        monsterNumber = opponentGroundNumbers[monsterNumber - 1] - 1;\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!(this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE) && (this.selectedCard.getCard() instanceof MonsterCard) && (this.player.getBoard().getMonsterConditionByNumber(this.selectedCard.getNumber()).equals(\"OO\"))))\r\n            throw new CanNotAttack();\r\n        if (!(this.phase.equals(Phase.BATTLE_PHASE)))\r\n            throw new CantDoActionInThisPhase();\r\n        if (actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).contains(ActionsDoneInTurn.ATTACK))\r\n            throw new AlreadyAttacked();\r\n        if (getCountOfMonsterCardsInGround(this.rival) == 0)\r\n            throw new NoCardToAttack();\r\n        String targetPosition = this.rival.getBoard().getMonsterConditionByNumber(monsterNumber);\r\n        if (this.rival.getBoard().getMonsterByNumber(monsterNumber).canBeAttacked(this, monsterNumber)) {\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.ATTACKED, this.rival, monsterNumber);\r\n            switch (targetPosition) {\r\n                case \"OO\":\r\n                    attackMonsterOO(monsterNumber);\r\n                    break;\r\n                case \"DO\":\r\n                    attackMonsterDO(monsterNumber);\r\n                    break;\r\n                case \"DH\":\r\n                    attackMonsterDH(monsterNumber);\r\n                    break;\r\n            }\r\n        } else throw new CanNotAttackThisCard();\r\n    }\r\n\r\n    private void attackMonsterOO(int monsterNumber) throws Exception {\r\n        int attackerAttack = this.playerAttackPoints[this.selectedCard.getNumber()];\r\n        int targetAttack = this.rivalAttackPoints[monsterNumber];\r\n        if (attackerAttack > targetAttack) {\r\n            int damage = attackerAttack - targetAttack;\r\n            if (!this.rival.getBoard().getMonsterByNumber(monsterNumber).equals(MonsterCard.EXPLODER_DRAGON))\r\n                this.rival.decreaseLifePoint(damage);\r\n            this.rival.getBoard().putInGraveYard(this.rival.getBoard().getMonsterByNumber(monsterNumber));\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"your opponent’s monster is destroyed and your opponent receives \" + damage + \" battle damage\");\r\n        } else if (attackerAttack == targetAttack) {\r\n            this.rival.getBoard().putInGraveYard(this.rival.getBoard().getMonsterByNumber(monsterNumber));\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            if (this.player.getBoard().getMonsterByNumber(this.selectedCard.getNumber()) != null) {\r\n                this.player.getBoard().putInGraveYard(this.selectedCard.getCard());\r\n                this.player.getBoard().removeMonster(this.selectedCard.getNumber());\r\n                removeMonsterPlayer(this.selectedCard.getNumber());\r\n            }\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"both you and your opponent monster cards are destroyed and no one receives damage\");\r\n        } else {\r\n            int damage = targetAttack - attackerAttack;\r\n            this.player.decreaseLifePoint(damage);\r\n            ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.REMOVE_FROM_MONSTERZONE, this.player, this.selectedCard.getNumber());\r\n            this.player.getBoard().putInGraveYard(this.selectedCard.getCard());\r\n            this.player.getBoard().removeMonster(this.selectedCard.getNumber());\r\n            removeMonsterPlayer(this.selectedCard.getNumber());\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"Your monster card is destroyed and you received\" + damage + \"battle damage\");\r\n        }\r\n        unselectCard();\r\n        printBoard();\r\n    }\r\n\r\n    private void attackMonsterDO(int monsterNumber) throws Exception {\r\n        MonsterCard target = this.rival.getBoard().getMonsterByNumber(monsterNumber);\r\n        int attackerAttack = this.playerAttackPoints[this.selectedCard.getNumber()];\r\n        if (attackerAttack > target.getDefence()) {\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            this.rival.getBoard().putInGraveYard(target);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"the defense position monster is destroyed\");\r\n        } else if (attackerAttack == target.getDefence()) {\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"no card is destroyed\");\r\n        } else {\r\n            int damage = target.getDefence() - attackerAttack;\r\n            this.player.decreaseLifePoint(damage);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"no card is destroyed and you received\" + damage + \" battle damage\");\r\n        }\r\n        unselectCard();\r\n        printBoard();\r\n    }\r\n\r\n    private void attackMonsterDH(int monsterNumber) throws Exception {\r\n        MonsterCard target = this.rival.getBoard().getMonsterByNumber(monsterNumber);\r\n        int attackerAttack = this.playerAttackPoints[this.selectedCard.getNumber()];\r\n        String targetName = this.rival.getBoard().getMonsterByNumber(monsterNumber).getName();\r\n        this.rival.getBoard().changeMonsterPosition(monsterNumber, \"DO\");\r\n        ((MonsterCard) this.selectedCard.getCard()).takeAction(this, TakeActionCase.FLIP_SUMMONED, this.rival, this.selectedCard.getNumber());\r\n        if (attackerAttack > target.getDefence()) {\r\n            this.rival.getBoard().putInGraveYard(target);\r\n            this.rival.getBoard().getMonsterByNumber(monsterNumber).takeAction(this, TakeActionCase.DIED_BY_BEING_ATTACKED, this.rival, monsterNumber);\r\n            this.rival.getBoard().removeMonster(monsterNumber);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"opponent’s monster card was \" + targetName + \" and the defense position monster is destroyed\");\r\n        } else if (attackerAttack == target.getDefence()) {\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"opponent’s monster card was \" + targetName + \" and no card is destroyed\");\r\n        } else {\r\n            int damage = target.getDefence() - attackerAttack;\r\n            this.player.decreaseLifePoint(damage);\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            DuelView.printText(\"opponent’s monster card was \" + targetName + \" and no card is destroyed and you received\" + damage + \" battle damage\");\r\n        }\r\n        unselectCard();\r\n        printBoard();\r\n    }\r\n\r\n    public void directAttack() throws Exception {\r\n        if (this.selectedCard == null) throw new NoCardSelected();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.MONSTERZONE)) throw new CanNotAttack();\r\n        if (!this.phase.equals(Phase.BATTLE_PHASE)) throw new ImproperPhase();\r\n        int countOfMonsterCardsInGround = getCountOfMonsterCardsInGround(this.rival);\r\n        if (countOfMonsterCardsInGround == 0) {\r\n            rival.decreaseLifePoint(((MonsterCard) this.selectedCard.getCard()).getAttack());\r\n            actionsOnThisCardPlayer.get(this.selectedCard.getNumber()).add(ActionsDoneInTurn.ATTACK);\r\n            unselectCard();\r\n            printBoard();\r\n        } else throw new CanNotAttackDirectly();\r\n        printBoard();\r\n    }\r\n\r\n    public void activateSpell() throws Exception {\r\n        if (this.selectedCard == null)\r\n            throw new NoCardSelected();\r\n        if (!(this.selectedCard.getCard() instanceof SpellCard))\r\n            throw new IsNotSpell();\r\n        if (!((this.phase.equals(Phase.MAIN_PHASE1)) || (this.phase.equals(Phase.MAIN_PHASE2))))\r\n            throw new CanNotActivateEffectOnThisTurn();\r\n        if (!this.selectedCard.getBoardZone().equals(BoardZone.HAND))\r\n            throw new AlreadyActivated();\r\n        SpellCard spellCard = (SpellCard) this.selectedCard.getCard();\r\n        if (this.player.getBoard().isFullSpellAndTrapZone() && !spellCard.getIcon().equals(Icon.FIELD))\r\n            throw new FullSpellZone();\r\n//        if (/*sahrti dasht ke nemishod faal kard */) throw new UndonePreparationOfSpell();\r\n        if (spellCard.getIcon().equals(Icon.FIELD)) {\r\n            if (this.player.getBoard().getFieldZone() != null) {\r\n                this.player.getBoard().putInGraveYard(this.player.getBoard().getFieldZone());\r\n                this.player.getBoard().removeFromFieldZone();\r\n            }\r\n            //TODO age lazeme condition ham pas bede\r\n            this.player.getBoard().putInFieldZone(spellCard);\r\n        } else {\r\n            this.player.getBoard().putSpellOrTrap(spellCard, \"O\");\r\n        }\r\n        this.player.getBoard().getCardsInHand().remove(this.selectedCard.getNumber() - 1);\r\n        unselectCard();\r\n        DuelView.printText(\"spell activated\");\r\n        printBoard();\r\n    }\r\n    //     if (/*ritual spell ya ritual summon she bad dasture dgei vared she*/)\r\n    //      DuelView.printText(\"you should ritual summon right now\");\r\n /*\r\n    private void ritualSummon() throws Exception{\r\n        if (this.selectedCard.getCard() == null) throw new NoCardSelected();\r\n        if(/*agar ritual tu dastemun nabud ya majmue sutuh .. barabar nabud */ //)\r\n\r\n            /*throw new CanNotRitualSummon();\r\n        if (this.selectedCard.getCard() instanceof SpellCard) ritualSpell();\r\n        if (this.selectedCard.getCard() instanceof MonsterCard) ritualMonster();\r\n    }\r\n\r\n    private void ritualSpell() throws Exception{\r\n\r\n    }\r\n    private void ritualMonster() throws Exception{\r\n\r\n    }\r\n*/\r\n\r\n    private void ritualSummon() throws Exception {\r\n\r\n\r\n    }\r\n\r\n    private void activateSpellOrTrapInRivalsTurn() throws Exception {\r\n        /*sharayet bar ghara bud*/\r\n        if (true) {\r\n            DuelView.printText(\"do you want to activate your trap and spell?\");\r\n            String input = DuelView.scan();\r\n            if (input.equals(\"yes\")) {\r\n//                if (/*kare digei anjam shod*/) throw new NotYourTurnForThisAction();\r\n                //faal sazie YEK card ke sharayetesh hast va ru zamine\r\n                DuelView.printText(\"spell/trap activated\");\r\n            } else if (input.equals(\"no\")) {\r\n                DuelView.printText(\"now it will be \" + this.player + \"'s turn\");\r\n                printBoard();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void cheatLifePoint(String target, int lifePoint) {\r\n        if (lifePoint < 2000) {\r\n            if (target.equals(\"player\"))\r\n                this.player.increaseLifePoint(lifePoint);\r\n            if (target.equals(\"opponent\"))\r\n                this.rival.decreaseLifePoint(lifePoint);\r\n            DuelView.printText(\"shame on you for cheating!!!!\");\r\n        }\r\n    }\r\n\r\n    public void cheatMoney(int amount) {\r\n        if (amount <= 5000)\r\n            this.player.increaseMoney(amount);\r\n        DuelView.printText(\"shame on you for cheating!!!!\");\r\n    }\r\n\r\n    //TODO lotfan ino check konin ok bashe\r\n    // be nazare man ke okeye(parmida)\r\n    public void cheatToWinGame() {\r\n        DuelView.printText(\"this is not a good way to win the game, but ok. Shame on you!\");\r\n        endGame(this.rival);\r\n    }\r\n\r\n    /*private void checkForChangesWhenAttackedMonster(int monsterNumber) {\r\n        switch (this.rival.getBoard().getMonsterByNumber(monsterNumber)) {\r\n            case COMMAND_KNIGHT:\r\n                changeAllAttackPointsBy400(-1);\r\n                break;\r\n        }\r\n    }*/\r\n\r\n    public void changeAllAttackPoints(int increaseOrDecrease,int amount){\r\n        Board playerBoard = this.player.getBoard();\r\n        Board rivalBoard= this.rival.getBoard();\r\n        for (int i = 0; i < 5; i++) {\r\n            if(playerBoard.getMonsterByNumber(i)!=null) this.playerAttackPoints[i]=this.playerAttackPoints[i]+increaseOrDecrease*amount;\r\n            if(rivalBoard.getMonsterByNumber(i)!=null) this.rivalAttackPoints[i]=this.rivalAttackPoints[i]+increaseOrDecrease*amount;\r\n        }\r\n    }\r\n\r\n    public void surrender() {\r\n        //todo shayad lazem bashe darbare in bishter tafakor konim\r\n        endGame(this.player);\r\n    }\r\n\r\n    public void manageEndGame() {\r\n        List<Cardable> playersCardInHand = player.getBoard().getCardsInHand();\r\n        List<Cardable> rivalsCardInHand = rival.getBoard().getCardsInHand();\r\n        if (player.getLifePoint() <= 0) {\r\n            endGame(player);\r\n        } else if (rival.getLifePoint() <= 0) {\r\n            endGame(rival);\r\n        } else if (playersCardInHand.isEmpty()) {\r\n            endGame(player);\r\n        } else if (rivalsCardInHand.isEmpty()) {\r\n            endGame(rival);\r\n        }\r\n    }\r\n\r\n    private void endGame(User loser) {\r\n        User winner;\r\n        if (loser.equals(rival)) {\r\n            winner = player;\r\n        } else {\r\n            winner = rival;\r\n        }\r\n        roundCounter++;\r\n        if (roundNumber == 1) {\r\n            winner.increaseScore(1000);\r\n            winner.increaseMoney(1000 + winner.getLifePoint());\r\n            loser.increaseMoney(100);\r\n            shouldEndGameForView = true;\r\n            DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n        }\r\n        if (roundNumber == 3) {\r\n            this.rounds[this.roundCounter - 1] = new Round(winner, loser, winner.getLifePoint(), loser.getLifePoint());\r\n            if (this.roundCounter == 2 && this.rounds[0].getWinner().equals(this.rounds[1].getWinner())) {\r\n                int winnerLP1 = this.rounds[0].getLifePointByUser(winner);\r\n                int winnerLP2 = this.rounds[1].getLifePointByUser(winner);\r\n                int maxLP = Math.max(winnerLP1, winnerLP2);\r\n                winner.increaseScore(3000);\r\n                winner.increaseMoney(3000 + (3 * maxLP));\r\n                loser.increaseMoney(300);\r\n                shouldEndGameForView = true;\r\n                DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n                DuelView.printText(winner.getUsername() + \" won the whole match with score: \" + winner.getScore() + \"-\" + loser.getScore());\r\n            } else if (roundCounter == 3) {\r\n                int winnerLP1 = this.rounds[0].getLifePointByUser(winner);\r\n                int winnerLP2 = this.rounds[1].getLifePointByUser(winner);\r\n                int winnerLP3 = this.rounds[2].getLifePointByUser(winner);\r\n                int maxLP = Math.max(winnerLP1, winnerLP2);\r\n                maxLP = Math.max(maxLP, winnerLP3);\r\n                winner.increaseScore(3000);\r\n                winner.increaseMoney(3000 + (3 * maxLP));\r\n                loser.increaseMoney(300);\r\n                shouldEndGameForView = true;\r\n                DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n                DuelView.printText(winner.getUsername() + \" won the whole match with score: \" + winner.getScore() + \"-\" + loser.getScore());\r\n            } else {\r\n                DuelView.printText(winner.getUsername() + \" won the game and the score is: \" + winner.getScore() + \"-\" + loser.getScore());\r\n                exchangeCardBetweenMainAndSide(this.player);\r\n                exchangeCardBetweenMainAndSide(this.rival);\r\n                startNewGame(winner);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void exchangeCardBetweenMainAndSide(User user) {\r\n        DuelView.printText(\"Do you want to exchange a card between main and side deck \" + user.getNickname() + \"?\");\r\n        String answer = DuelView.scan().toLowerCase(Locale.ROOT);\r\n        if (answer.equals(\"yes\")) { //todo balayi ro tolowercase kardam va ino bardashtam :  || answer.equals(\"Yes\")\r\n            DuelView.printText(\"enter card name from main and side\");\r\n            String main = DuelView.scan();\r\n            Cardable mainCard = user.getCardByName(main);\r\n            while (mainCard == null || !user.getGameDeck().getMainDeck().contains(mainCard)) {\r\n                DuelView.printText(\"Please enter a card you have in your main deck!\");\r\n                main = DuelView.scan();\r\n                mainCard = user.getCardByName(main);\r\n            }\r\n            String side = DuelView.scan();\r\n            Cardable sideCard = user.getCardByName(side);\r\n            while (sideCard == null || !user.getGameDeck().getSideDeck().contains(sideCard)) {\r\n                DuelView.printText(\"Please enter a card you have in your side deck!\");\r\n                side = DuelView.scan();\r\n                sideCard = user.getCardByName(side);\r\n            }\r\n            user.getGameDeck().getSideDeck().remove(sideCard);\r\n            user.getGameDeck().getMainDeck().remove(mainCard);\r\n            user.getGameDeck().getSideDeck().add(mainCard);\r\n            user.getGameDeck().getMainDeck().add(sideCard);\r\n        }\r\n    }\r\n\r\n    public void goNextPhase() {\r\n        //TODO in kar dare hala\r\n        if (this.phase.equals(Phase.DRAW_PHASE)) {\r\n            this.phase = Phase.STANDBY_PHASE;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n        } else if (phase.equals(Phase.STANDBY_PHASE)) {\r\n            this.phase = Phase.MAIN_PHASE1;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n            printBoard();\r\n        } else if (phase.equals(Phase.MAIN_PHASE1)) {\r\n            if (!isStartTurn)\r\n                this.phase = Phase.BATTLE_PHASE;\r\n            else\r\n                this.phase = Phase.MAIN_PHASE2;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n        } else if (this.phase.equals(Phase.BATTLE_PHASE)) {\r\n            this.phase = Phase.MAIN_PHASE2;\r\n            DuelView.printText(\"phase: \" + this.phase.getNamePascalCase());\r\n        } else if (this.phase.equals(Phase.MAIN_PHASE2)) {\r\n            this.phase = Phase.END_PHASE;\r\n        } else if (this.phase.equals(Phase.END_PHASE)) {\r\n            DuelView.printText(\"phase: \" + phase.getNamePascalCase());\r\n            DuelView.printText(\"its \" + rival.getNickname() + \"’s turn\");\r\n            changeTurn();\r\n            startDrawPhase(false);\r\n        }\r\n    }\r\n\r\n    private void startDrawPhase(boolean isFirstTime) {\r\n        this.phase = Phase.DRAW_PHASE;\r\n        ArrayList<Cardable> playerMainCards = (ArrayList<Cardable>) this.player.getGameDeck().getMainDeck();\r\n        ArrayList<Cardable> rivalMainCards = (ArrayList<Cardable>) this.rival.getGameDeck().getMainDeck();\r\n        if (playerMainCards.size() == 0) endGame(this.player);\r\n        else {\r\n            if (!isFirstTime) {\r\n                this.player.getBoard().addCardToHand(playerMainCards.get(playerMainCards.size() - 1));\r\n                this.player.getGameDeck().removeCardFromMainDeck(playerMainCards.get(playerMainCards.size() - 1));\r\n                Collections.shuffle(this.player.getGameDeck().getMainDeck());\r\n                DuelView.printText(\"new card added to the hand : \" + playerMainCards.get(playerMainCards.size() - 1).getNamePascalCase());\r\n            } else {\r\n                for (int i = 0; i < 5; i++) {\r\n                    this.player.getBoard().addCardToHand(playerMainCards.get(playerMainCards.size() - 1));\r\n                    this.player.getGameDeck().removeCardFromMainDeck(playerMainCards.get(playerMainCards.size() - 1));\r\n                    this.rival.getBoard().addCardToHand(rivalMainCards.get(rivalMainCards.size() - 1));\r\n                    this.rival.getGameDeck().removeCardFromMainDeck(rivalMainCards.get(rivalMainCards.size() - 1));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void changeTurn() {\r\n        if (this.isStartTurn) this.isStartTurn = false;\r\n        clearLastTurn();\r\n        //TODO inam hanooz kar dare\r\n        User temp = this.player;\r\n        this.player = rival;\r\n        this.rival = temp;\r\n        changePlayerAndRival();\r\n        if (this.player.getUsername().equals(\"@AI@\"))\r\n            handleAITurn();\r\n\r\n    }\r\n\r\n    public void changePlayerAndRival(){\r\n        Integer[] temp = this.playerAttackPoints;\r\n        this.playerAttackPoints = this.rivalAttackPoints;\r\n        this.rivalAttackPoints = temp;\r\n    }\r\n\r\n    private void clearLastTurn() {\r\n        this.selectedCard = null;\r\n        this.hasSummonedOrSetInThisTurn = false;\r\n        /*this.hasUsedHeraldInThisTurn = false;\r\n        this.hasUsedTexChangerInThisTurn = false;*/\r\n        newThoseThatResetWithTurn();\r\n    }\r\n\r\n    private void newThoseThatResetWithTurn(){\r\n        for (int i = 0; i < 5; i++) {\r\n            actionsOnThisCardPlayer.get(i).clear();\r\n            if(this.playerAttackPoints[i]!=null && this.playerAttackPoints[i]==0 && this.player.getBoard().getMonsterByNumber(i).getAttack()!=0){\r\n                this.playerAttackPoints[i] = this.player.getBoard().getMonsterByNumber(i).getAttack();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void printBoard() {\r\n        String toPrint = this.rival.getNickname() + \":\" + this.rival.getLifePoint() + \"\\n\";\r\n        for (Cardable ignored : this.rival.getBoard().getCardsInHand()) {\r\n            toPrint += \"\\tc\";\r\n        }\r\n        toPrint += \"\\n\";\r\n        toPrint += this.rival.getGameDeck().getMainSize() + \"\\n\";\r\n        for (int i = 4; i > -1; i--) {\r\n            toPrint += \"\\t\";\r\n            if (this.rival.getBoard().getSpellAndTrapConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.rival.getBoard().getSpellAndTrapConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\n\";\r\n        for (int i = 4; i > -1; i--) {\r\n            toPrint += \"\\t\";\r\n            if (this.rival.getBoard().getMonsterConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.rival.getBoard().getMonsterConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\n\" + this.rival.getBoard().getCardsInGraveyard().size() + \"\\t\\t\\t\\t\\t\\t\";\r\n        if (this.rival.getBoard().getFieldZone() == null) toPrint += \"E\\n\";\r\n        else toPrint += \"O\\n\";\r\n        toPrint += \"\\n--------------------------\\n\\n\";\r\n        if (this.player.getBoard().getFieldZone() == null) toPrint += \"E\\t\\t\\t\\t\\t\\t\";\r\n        else toPrint += \"O\\t\\t\\t\\t\\t\\t\";\r\n        toPrint += this.player.getBoard().getCardsInGraveyard().size() + \"\\n\";\r\n        for (int i = 0; i < 5; i++) {\r\n            toPrint += \"\\t\";\r\n            if (this.player.getBoard().getMonsterConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.player.getBoard().getMonsterConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\n\";\r\n        for (int i = 0; i < 5; i++) {\r\n            toPrint += \"\\t\";\r\n            if (this.player.getBoard().getSpellAndTrapConditionByNumber(i) == null) toPrint += \"E\";\r\n            else toPrint += this.player.getBoard().getSpellAndTrapConditionByNumber(i);\r\n        }\r\n        toPrint += \"\\t\\t\\t\\t\\t\\t\" + this.player.getGameDeck().getMainSize() + \"\\n\";\r\n        for (Cardable ignored : this.player.getBoard().getCardsInHand()) {\r\n            toPrint += \"c\\t\";\r\n        }\r\n        toPrint += \"\\n\" + this.player.getNickname() + \":\" + this.player.getLifePoint();\r\n        DuelView.printText(toPrint);\r\n    }\r\n\r\n    public void showCard() throws Exception {\r\n        if (this.selectedCard == null) {\r\n            throw new NoCardSelected();\r\n        } else if (!this.selectedCard.getOwner().equals(this.player)) {\r\n            throw new InvisibleCard();\r\n        } else\r\n            DuelView.printText(this.selectedCard.getCard().toString());\r\n    }\r\n\r\n    public void showGraveyard() throws Exception {\r\n        List<Cardable> graveyard = this.player.getBoard().getCardsInGraveyard();\r\n        String toPrint = \"\";\r\n        if (graveyard.isEmpty())\r\n            throw new GraveYardEmpty();\r\n        else {\r\n            for (Cardable cardInGraveyard : graveyard) {\r\n                if (graveyard.indexOf(cardInGraveyard) == graveyard.size() - 1) {\r\n                    toPrint += cardInGraveyard.getName() + \":\" + cardInGraveyard.getDescription();\r\n                } else {\r\n                    toPrint += cardInGraveyard.getName() + \":\" + cardInGraveyard.getDescription() + \"\\n\";\r\n                }\r\n            }\r\n        }\r\n        DuelView.printText(toPrint);\r\n        String input = DuelView.scan();\r\n        while (!input.equals(\"back\")) {\r\n            DuelView.printText(\"invalid command\");\r\n            input = DuelView.scan();\r\n        }\r\n    }\r\n\r\n    public void removeMonsterPlayer(int address) {\r\n        actionsOnThisCardPlayer.get(address).clear();\r\n        /*monsterZone.setHasChangedPositionInThisTurn(address, false);\r\n        monsterZone.setHasSetInThisTurn(address, false);\r\n        monsterZone.setMonsterAttackPlayer(address, null);*/\r\n        setMonsterAttackPlayer(address, null);\r\n        player.getBoard().removeMonster(address);\r\n        ((MonsterCard) selectedCard.getCard()).takeAction(this, TakeActionCase.REMOVE_FROM_MONSTERZONE, this.player, this.selectedCard.getNumber());\r\n    }\r\n\r\n    public void handleAITurn() {\r\n        setMonsterCardInAI();\r\n        changePositionInAI();\r\n        setSpellOrTrapInAI();\r\n        goNextPhase();\r\n        attackInAI();\r\n        //TODO faal sazie spell o trap\r\n        goNextPhase();\r\n        setSpellOrTrapInAI();\r\n        changeTurn();\r\n    }\r\n\r\n    //fixme un exception haye duc ro bara set monster biam inja check konam\r\n    //TODO in mokhalefe 10 haro check konam. (age na vazehe baratun ye jur null pointer e. tabe haye most oleast AI ro bebinin migiri dastano)\r\n\r\n    private void setMonsterCardInAI(){\r\n        int numberOfMonstersOnPlayerBoard =numberOfMonstersOnPlayerBoard();\r\n        if (numberOfMonstersOnPlayerBoard > 1 && monsterCardWithTwoTributesWithMaxAttackPointInHand() != null)\r\n            setATwoTributeMonster();\r\n        else if (numberOfMonstersOnPlayerBoard > 0 && monsterCardWithOneTributeWithMaxAttackPointInHand() != null)\r\n            setAOneTributeMonster();\r\n        else if (numberOfMonstersOnPlayerBoard != 5 && monsterCardWithoutTributeWithMaxAttackPointInHand() != null)\r\n            setANoTributeMonster();\r\n    }\r\n\r\n    private void setATwoTributeMonster(){\r\n        if (numberOfLevelSevenEightMonstersInHand() > 0) {\r\n            this.player.getBoard().removeMonster(monsterCardWithLeaseAttackPointOnPlayerBoard());\r\n            this.player.getBoard().removeMonster(monsterCardWithLeaseAttackPointOnPlayerBoard());\r\n            this.player.getBoard().putMonster(monsterCardWithTwoTributesWithMaxAttackPointInHand(), \"OO\");\r\n        }\r\n\r\n    }\r\n\r\n    private void setAOneTributeMonster() {\r\n        if (numberOfLevelFiveSixMonstersInPlayerHand() > 0) {\r\n            this.player.getBoard().removeMonster(monsterCardWithLeaseAttackPointOnPlayerBoard());\r\n            this.player.getBoard().putMonster(monsterCardWithOneTributeWithMaxAttackPointInHand(), \"OO\");\r\n        }\r\n    }\r\n\r\n    private void setANoTributeMonster() {\r\n        if (numberOfLevelOneTwoFourMonstersInPlayerHand() > 0) {\r\n            if (monsterCardWithoutTributeWithMaxAttackPointInHand() != null && monsterCardWithLeastDefencePointOnRivalBoard() != 10)\r\n                if (numberOfMonstersOnPlayerBoard() == 0 && monsterCardWithoutTributeWithMaxAttackPointInHand().getAttack() < monsterCardWithLeaseAttackPointOnPlayerBoard())\r\n                    this.player.getBoard().putMonster(monsterCardWithMaxDefenseInHand(), \"DH\");\r\n                else if (numberOfMonstersOnPlayerBoard() < 5)\r\n                    this.player.getBoard().putMonster(monsterCardWithoutTributeWithMaxAttackPointInHand(), \"OO\");\r\n        }\r\n    }\r\n\r\n    private void setSpellOrTrapInAI(){\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i <numberOfCardsInHand ; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof SpellCard || card instanceof TrapCard)\r\n                if (numberOfSpellsAndTrapsOnPlayerBoard() < 5)\r\n                    this.player.getBoard().putSpellOrTrap(card,\"H\");\r\n        }\r\n    }\r\n\r\n    //TODO monster ha ke set mishan unayi ke monstercard return mikonan shayad null bede!\r\n    //TODO biad bad az har bar attack alamat bezanatesh ke ta hala bahash atack zade\r\n    private void attackInAI(){\r\n        if (numberOfMonstersOnPlayerBoard() > 0) {\r\n            ArrayList<Integer> hasAttacked = new ArrayList<>();\r\n            if (numberOfMonstersOnRivalBoard() == 0)\r\n                directAttackInAI();\r\n            if (allCardsOnRivalAreDH()) {\r\n                int numberOfAttacks = minFinder(numberOfMonstersOnRivalBoard(),numberOfMonstersOnPlayerBoard());\r\n                for (int i = 0; i < numberOfAttacks; i++) {\r\n                    //TODO if already bahash attack nazade\r\n                    attackAllDHInAI();\r\n                }\r\n            }\r\n            if (monsterCardWithMostAttackPointOnPlayerBoard() != 10 && monsterCardWithMostAttackPointOnRivalBoard() != 10) {\r\n                attackOOInAI();\r\n                if (numberOfMonstersOnRivalBoard() == 0)\r\n                    directAttackInAI();\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean allCardsOnRivalAreDH(){\r\n        int counterOfDH = 0;\r\n        int counterOfCards = 0;\r\n        for (int i = 1; i < 6; i++) {\r\n            if (this.rival.getBoard().getMonsterByNumber(i) != null) {\r\n                counterOfCards++;\r\n                if (!this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"DH\"))\r\n                    counterOfDH++;\r\n            }\r\n        }\r\n        if (counterOfDH == counterOfCards)\r\n            return true;\r\n        else return false;\r\n    }\r\n\r\n    private void directAttackInAI(){\r\n        for (int i = 1; i < 6 ; i++) {\r\n            MonsterCard monsterCard = this.player.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null) {\r\n                try {\r\n                    selectCardPlayerMonsterZone(i);\r\n                    directAttack();\r\n                    unselectCard();\r\n                } catch (Exception exception) {\r\n                    exception.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void attackAllDHInAI(){\r\n        try {\r\n            selectCardPlayerMonsterZone(monsterCardWithMostAttackPointOnPlayerBoard());\r\n            int wantedMonster = 0;\r\n            for (int i = 1; i < 6; i++) {\r\n                MonsterCard monsterCard = this.rival.getBoard().getMonsterByNumber(i);\r\n                if (monsterCard != null){\r\n                    wantedMonster = i;\r\n                    break;\r\n                }\r\n            }\r\n            attackMonsterDH(wantedMonster);\r\n        } catch (Exception exception) {\r\n            exception.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void attackOOInAI(){\r\n        if (this.rival.getBoard().getMonsterConditionByNumber(monsterCardWithMostAttackPointOnRivalBoard()).equals(\"OO\")) {\r\n            MonsterCard strongestRivalAttacker = this.rival.getBoard().getMonsterByNumber(monsterCardWithLeaseAttackPointOnRivalBoard());\r\n            MonsterCard strongestPlayerAttacker = this.player.getBoard().getMonsterByNumber(monsterCardWithMostAttackPointOnPlayerBoard());\r\n            if (strongestPlayerAttacker.getAttack() > strongestRivalAttacker.getAttack()){\r\n                //TODO exception already attacked\r\n                try {\r\n                    attackMonsterOO(monsterCardWithMostAttackPointOnRivalBoard());\r\n                } catch (Exception exception) {\r\n                    exception.printStackTrace();\r\n                }\r\n            }\r\n            int indexOfSecondStrongestAttackerOnRival = monsterCardWithSecondMostAttackPointOnRivalBoard(monsterCardWithMostAttackPointOnRivalBoard());\r\n            MonsterCard secondStrongestRivalAttacker = this.rival.getBoard().getMonsterByNumber(indexOfSecondStrongestAttackerOnRival);\r\n            if (secondStrongestRivalAttacker.getAttack() < strongestPlayerAttacker.getAttack())\r\n            //fixme selectCard o in chiza ke alan vaghan halesho nadaram\r\n            {\r\n                try {\r\n                    attackMonsterOO(indexOfSecondStrongestAttackerOnRival);\r\n                } catch (Exception exception) {\r\n                    exception.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void changePositionInAI(){\r\n        MonsterCard leastAttackerOnRival = this.rival.getBoard().getMonsterByNumber(monsterCardWithLeaseAttackPointOnRivalBoard());\r\n        MonsterCard strongestAttackerOnPlayer = this.player.getBoard().getMonsterByNumber(monsterCardWithMostAttackPointOnPlayerBoard());\r\n        if (leastAttackerOnRival.getAttack() > strongestAttackerOnPlayer.getAttack());\r\n        for (int i = 1; i < 6; i++) {\r\n            MonsterCard monsterCard = this.player.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null)\r\n                this.player.getBoard().changeMonsterPosition(i,\"DO\");\r\n        }\r\n    }\r\n\r\n    //varede nahie debug shodeye shaki mishavid\r\n    private MonsterCard monsterCardWithoutTributeWithMaxAttackPointInHand(){\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getLevel() < 5)\r\n                        if (((MonsterCard) card).getAttack() > maxAttackPoint) {\r\n                            maxAttackPoint = ((MonsterCard) card).getAttack();\r\n                            indexOfMaxAttacker = i;\r\n                        }\r\n            }\r\n        }\r\n        if (indexOfMaxAttacker != 10)\r\n            return this.player.getBoard().getMonsterByNumber(indexOfMaxAttacker);\r\n        else return null;\r\n    }\r\n\r\n    private MonsterCard monsterCardWithOneTributeWithMaxAttackPointInHand(){\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getLevel() == 5 || ((MonsterCard) card).getLevel() == 6)\r\n                        if (((MonsterCard) card).getAttack() > maxAttackPoint) {\r\n                            maxAttackPoint = ((MonsterCard) card).getAttack();\r\n                            indexOfMaxAttacker = i;\r\n                        }\r\n            }\r\n        }\r\n        if (indexOfMaxAttacker != 10)\r\n            return this.player.getBoard().getMonsterByNumber(indexOfMaxAttacker);\r\n        else return null;\r\n    }\r\n\r\n    private MonsterCard monsterCardWithTwoTributesWithMaxAttackPointInHand(){\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getLevel() > 6)\r\n                        if (((MonsterCard) card).getAttack() > maxAttackPoint) {\r\n                            maxAttackPoint = ((MonsterCard) card).getAttack();\r\n                            indexOfMaxAttacker = i;\r\n                        }\r\n            }\r\n        }\r\n        if (indexOfMaxAttacker != 10)\r\n            return (MonsterCard) this.player.getBoard().getCardInHandByNumber(indexOfMaxAttacker);\r\n        else return null;\r\n    }\r\n\r\n    private MonsterCard monsterCardWithMaxDefenseInHand(){\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        int maxDefencePoint = 0;\r\n        int indexOfMaxDefender = 10;\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card != null) {\r\n                if (card instanceof MonsterCard)\r\n                    if (((MonsterCard) card).getDefence() > maxDefencePoint) {\r\n                        maxDefencePoint = ((MonsterCard) card).getDefence();\r\n                        indexOfMaxDefender = i;\r\n                    }\r\n            }\r\n        }\r\n        if (indexOfMaxDefender != 10)\r\n            return (MonsterCard) this.player.getBoard().getCardInHandByNumber(indexOfMaxDefender);\r\n        else return null;\r\n    }\r\n\r\n    private int monsterCardWithLeaseAttackPointOnRivalBoard(){\r\n        int leastAttackPoint = 100000;\r\n        int indexOfMinAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getSpellAndTrapConditionByNumber(i).equals(\"OO\"))\r\n                    if (leastAttackPoint > card.getAttack()) {\r\n                        indexOfMinAttacker = i;\r\n                        leastAttackPoint = card.getAttack();\r\n                    }\r\n        }\r\n        return indexOfMinAttacker;\r\n    }\r\n\r\n    private int monsterCardWithLeaseAttackPointOnPlayerBoard(){\r\n        int leastAttackPoint = 100000;\r\n        int indexOfMinAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.player.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.player.getBoard().getSpellAndTrapConditionByNumber(i).equals(\"OO\"))\r\n                    if (leastAttackPoint > card.getAttack()) {\r\n                        indexOfMinAttacker = i;\r\n                        leastAttackPoint = card.getAttack();\r\n                    }\r\n        }\r\n        return indexOfMinAttacker;\r\n    }\r\n\r\n    private int monsterCardWithSecondMostAttackPointOnRivalBoard(int indexOfStrongestAttacker){\r\n        int indexOfSecondStrongestAttacker = 10;\r\n        int secondMostAttackPoint = 0;\r\n        if (numberOfMonstersOnPlayerBoard() > 1) {\r\n            indexOfStrongestAttacker = monsterCardWithMostAttackPointOnRivalBoard();\r\n            for (int i = 1; i <= 5; i++) {\r\n                MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n                if (card != null)\r\n                    if (i != indexOfStrongestAttacker && this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"OO\")){\r\n                        if (secondMostAttackPoint < card.getAttack()) {\r\n                            indexOfSecondStrongestAttacker = i;\r\n                            secondMostAttackPoint = card.getAttack();\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n        return indexOfSecondStrongestAttacker;\r\n    }\r\n\r\n    private int monsterCardWithMostAttackPointOnPlayerBoard(){\r\n        int mostAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard card = this.player.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.player.getBoard().getSpellAndTrapConditionByNumber(i).equals(\"OO\"))\r\n                    if (mostAttackPoint < card.getAttack()) {\r\n                        indexOfMaxAttacker = i;\r\n                        mostAttackPoint = card.getAttack();\r\n                    }\r\n        }\r\n        return indexOfMaxAttacker;\r\n    }\r\n\r\n    private int monsterCardWithLeastDefencePointOnRivalBoard(){\r\n        int leastDefencePoint = 100000;\r\n        int indexOfMinDefender = 10;\r\n        for (int i = 1; i <= 5 ; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"DO\"))\r\n                    if (leastDefencePoint > card.getDefence()) {\r\n                        leastDefencePoint = card.getDefence();\r\n                        indexOfMinDefender = i;\r\n                    }\r\n        }\r\n        return indexOfMinDefender;\r\n    }\r\n\r\n    private int monsterCardWithMostAttackPointOnRivalBoard(){\r\n        int mostAttackPoint = 0;\r\n        int indexOfMaxAttacker = 10;\r\n        for (int i = 1; i <= 5  ; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if (this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"OO\"))\r\n                    if (mostAttackPoint < card.getAttack()) {\r\n                        mostAttackPoint = card.getAttack();\r\n                        indexOfMaxAttacker = i;\r\n                    }\r\n        }\r\n        return indexOfMaxAttacker;\r\n    }\r\n\r\n    private int monsterCardWithMostDefencePointOnRivalBoard(){\r\n        int mostDefencePoint = 0;\r\n        int indexOfMaxDefender = 10;\r\n        for (int i = 1; i <= 5 ; i++) {\r\n            MonsterCard card = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (card != null)\r\n                if(this.rival.getBoard().getMonsterConditionByNumber(i).equals(\"DO\"))\r\n                    if (mostDefencePoint < card.getDefence()) {\r\n                        indexOfMaxDefender = i;\r\n                        mostDefencePoint = card.getDefence();\r\n                    }\r\n        }\r\n        return indexOfMaxDefender;\r\n    }\r\n    //payane nahie debug shode shaki\r\n\r\n    //varede nahie debug shode (be omide khoda) tazmin shode mishavid\r\n    private int numberOfMonstersOnPlayerBoard(){\r\n        int numberOfMonsters = 0;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard monsterCard = this.player.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null)\r\n                numberOfMonsters ++;\r\n        }\r\n        return numberOfMonsters;\r\n    }\r\n\r\n    private int numberOfMonstersOnRivalBoard(){\r\n        int numberOfMonsters = 0;\r\n        for (int i = 1; i <= 5; i++) {\r\n            MonsterCard monsterCard = this.rival.getBoard().getMonsterByNumber(i);\r\n            if (monsterCard != null)\r\n                numberOfMonsters ++;\r\n        }\r\n        return numberOfMonsters;\r\n    }\r\n\r\n    private int numberOfSpellsAndTrapsOnPlayerBoard(){\r\n        int numberOfSpellsAndTraps = 0;\r\n        for (int i = 1; i <= 5 ; i++) {\r\n            Cardable card = this.player.getBoard().getSpellAndTrapByNumber(i);\r\n            if(card != null)\r\n                numberOfSpellsAndTraps++;\r\n        }\r\n        return numberOfSpellsAndTraps;\r\n    }\r\n\r\n    private int numberOfLevelOneTwoFourMonstersInPlayerHand(){\r\n        int numberOfWantedMonsters = 0;\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof MonsterCard)\r\n                if (((MonsterCard) card).getLevel() < 5)\r\n                    numberOfWantedMonsters++;\r\n        }\r\n        return numberOfWantedMonsters;\r\n    }\r\n\r\n    private int numberOfLevelFiveSixMonstersInPlayerHand(){\r\n        int numberOfWantedMonsters = 0;\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof MonsterCard)\r\n                if (((MonsterCard) card).getLevel() == 5 || ((MonsterCard) card).getLevel() == 6)\r\n                    numberOfWantedMonsters++;\r\n        }\r\n        return numberOfWantedMonsters;\r\n    }\r\n\r\n    private int numberOfLevelSevenEightMonstersInHand(){\r\n        int numberOfWantedMonsters = 0;\r\n        int numberOfCardsInHand = this.player.getBoard().getCardsInHand().size();\r\n        for (int i = 0; i < numberOfCardsInHand; i++) {\r\n            Cardable card = this.player.getBoard().getCardInHandByNumber(i);\r\n            if (card instanceof MonsterCard)\r\n                if (((MonsterCard) card).getLevel() > 6)\r\n                    numberOfWantedMonsters++;\r\n        }\r\n        return numberOfWantedMonsters;\r\n    }\r\n    //payane nahie debug shode\r\n\r\n    public int minFinder(int firstNumber, int secondNumber){\r\n        if (firstNumber >= secondNumber)\r\n            return secondNumber;\r\n        else return firstNumber;\r\n    }\r\n\r\n\r\n}\r\n\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/controller/DuelController.java	(revision 7f7108b19f275a68ca32b60240f17cc8f3739458)
-+++ src/main/java/controller/DuelController.java	(date 1624001491280)
-@@ -25,6 +25,8 @@
- //    private ArrayList<ArrayList<ActionsDoneInTurn>> actionsOnThisCardRival=new ArrayList<>(5);
-     private Integer[] playerAttackPoints;
-     private Integer[] rivalAttackPoints;
-+    private Integer[] playerDefencePoints;
-+    private Integer[] rivalDefencePoints;
-     /*private boolean hasUsedHeraldInThisTurn;
-     private boolean hasUsedTexChangerInThisTurn;*/
-     /*boolean[] hasChangedPositionInThisTurn;
-@@ -781,6 +783,22 @@
-         }
-     }
- 
-+    public void changePlayerAttackPoint(int address,int amount){
-+        this.playerAttackPoints[address]+=amount;
-+    }
-+
-+    public void changeRivalAttackPoint(int address,int amount){
-+        this.rivalAttackPoints[address]+=amount;
-+    }
-+
-+    public void changePlayerDefencePoint(int address,int amount){
-+        this.playerDefencePoints[address]+=amount;
-+    }
-+
-+    public void changeRivalDefencePoint(int address,int amount){
-+        this.rivalDefencePoints[address]+=amount;
-+    }
-+
-     public void surrender() {
-         //todo shayad lazem bashe darbare in bishter tafakor konim
-         endGame(this.player);
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"BranchesTreeState\">\r\n    <expand>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"LOCAL_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"GROUP_NODE:origin\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n    </expand>\r\n    <select />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"0b1707ad-3e75-4310-9619-956ec670ae1a\" name=\"Default Changelist\" comment=\"model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/controller/DuelController.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/controller/DuelController.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/model/MonsterAction.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/model/MonsterAction.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/model/MonsterCard.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/model/MonsterCard.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/model/SpellCard.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/model/SpellCard.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"FxmlFile\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MavenImportPreferences\">\r\n    <option name=\"generalSettings\">\r\n      <MavenGeneralSettings>\r\n        <option name=\"mavenHome\" value=\"C:\\Program Files\\JetBrains\\IntelliJ IDEA Community Edition 2020.2\\plugins\\maven\\lib\\maven3\" />\r\n      </MavenGeneralSettings>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1tf7blqKJ2Y0dLvEX2lrUssvKzj\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"project.structure.last.edited\" value=\"SDKs\" />\r\n    <property name=\"project.structure.proportion\" value=\"0.0\" />\r\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\r\n    <property name=\"restartRequiresConfirmation\" value=\"false\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"reference.projectsettings.compiler.javacompiler\" />\r\n  </component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyClassDialog.RECENTS_KEY\">\r\n      <recent name=\"controller.exeption\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Application.Main\">\r\n    <configuration name=\"LogInViewGraphic\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"view.LogInViewGraphic\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"view.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Main\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"ScoreBoardViewGraphic\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"view.ScoreBoardViewGraphic\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"view.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"SignUpViewGraphic\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"view.SignUpViewGraphic\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"view.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.Main\" />\r\n        <item itemvalue=\"Application.SignUpViewGraphic\" />\r\n        <item itemvalue=\"Application.ScoreBoardViewGraphic\" />\r\n        <item itemvalue=\"Application.LogInViewGraphic\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"0b1707ad-3e75-4310-9619-956ec670ae1a\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1623148364579</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1623148364579</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"ScoreBoardViewGraphic.java\">\r\n      <created>1623149665559</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623149665559</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"ScoreBoardViewGraphic.java\">\r\n      <created>1623149688409</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623149688409</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Error sign up\">\r\n      <created>1623151044078</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623151044078</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"model.SpellCard.java&#10;Monster Reborn + Terraforming\">\r\n      <created>1623868346229</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623868346229</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED\">\r\n      <created>1623946393997</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623946393997</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"ScoreBoardViewGraphic.java\" />\r\n    <MESSAGE value=\"Error sign up\" />\r\n    <MESSAGE value=\"model.SpellCard.java&#10;Monster Reborn + Terraforming\" />\r\n    <MESSAGE value=\"model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED\" />\r\n  </component>\r\n  <component name=\"WindowStateProjectService\">\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.bottom\" timestamp=\"1623766526113\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.bottom/0.0.1280.680@0.0.1280.680\" timestamp=\"1623766526113\" />\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.center\" timestamp=\"1623766526113\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.center/0.0.1280.680@0.0.1280.680\" timestamp=\"1623766526113\" />\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.left\" timestamp=\"1623766526113\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.left/0.0.1280.680@0.0.1280.680\" timestamp=\"1623766526113\" />\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.right\" timestamp=\"1623766526113\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"170\" key=\"GridCell.Tab.0.right/0.0.1280.680@0.0.1280.680\" timestamp=\"1623766526113\" />\r\n    <state x=\"221\" y=\"84\" key=\"IDE.errors.dialog\" timestamp=\"1623946267253\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"221\" y=\"84\" key=\"IDE.errors.dialog/0.0.1280.680@0.0.1280.680\" timestamp=\"1623946267253\" />\r\n    <state x=\"121\" y=\"51\" key=\"MergeDialog\" timestamp=\"1623868524101\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"121\" y=\"51\" key=\"MergeDialog/0.0.1280.680@0.0.1280.680\" timestamp=\"1623868524101\" />\r\n    <state x=\"280\" y=\"102\" key=\"MultipleFileMergeDialog\" timestamp=\"1623868524121\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"280\" y=\"102\" key=\"MultipleFileMergeDialog/0.0.1280.680@0.0.1280.680\" timestamp=\"1623868524121\" />\r\n    <state x=\"121\" y=\"0\" key=\"SettingsEditor\" timestamp=\"1623148484919\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"121\" y=\"0\" key=\"SettingsEditor/0.0.1280.680@0.0.1280.680\" timestamp=\"1623148484919\" />\r\n    <state x=\"233\" y=\"74\" key=\"Vcs.Push.Dialog.v2\" timestamp=\"1623946400386\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"233\" y=\"74\" key=\"Vcs.Push.Dialog.v2/0.0.1280.680@0.0.1280.680\" timestamp=\"1623946400386\" />\r\n    <state x=\"247\" y=\"0\" key=\"com.intellij.openapi.editor.actions.MultiplePasteAction$ClipboardContentChooser\" timestamp=\"1623936514260\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"247\" y=\"0\" key=\"com.intellij.openapi.editor.actions.MultiplePasteAction$ClipboardContentChooser/0.0.1280.680@0.0.1280.680\" timestamp=\"1623936514260\" />\r\n    <state x=\"458\" y=\"255\" key=\"com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2\" timestamp=\"1623766509277\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"458\" y=\"255\" key=\"com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.0.1280.680@0.0.1280.680\" timestamp=\"1623766509277\" />\r\n    <state x=\"297\" y=\"151\" key=\"run.anything.popup\" timestamp=\"1623931675250\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"297\" y=\"151\" key=\"run.anything.popup/0.0.1280.680@0.0.1280.680\" timestamp=\"1623931675250\" />\r\n  </component>\r\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- .idea/workspace.xml	(revision 7f7108b19f275a68ca32b60240f17cc8f3739458)
-+++ .idea/workspace.xml	(date 1624001491684)
-@@ -22,12 +22,11 @@
-     <select />
-   </component>
-   <component name="ChangeListManager">
--    <list default="true" id="0b1707ad-3e75-4310-9619-956ec670ae1a" name="Default Changelist" comment="model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED">
-+    <list default="true" id="0b1707ad-3e75-4310-9619-956ec670ae1a" name="Default Changelist" comment="spell action">
-       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-       <change beforePath="$PROJECT_DIR$/src/main/java/controller/DuelController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/DuelController.java" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/src/main/java/model/MonsterAction.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/model/MonsterAction.java" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/src/main/java/model/MonsterCard.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/model/MonsterCard.java" afterDir="false" />
-       <change beforePath="$PROJECT_DIR$/src/main/java/model/SpellCard.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/model/SpellCard.java" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/src/main/java/model/TakeActionCase.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/model/TakeActionCase.java" afterDir="false" />
-     </list>
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-@@ -170,7 +169,14 @@
-       <option name="project" value="LOCAL" />
-       <updated>1623946393997</updated>
-     </task>
--    <option name="localTasksCounter" value="6" />
-+    <task id="LOCAL-00006" summary="spell action">
-+      <created>1623953953357</created>
-+      <option name="number" value="00006" />
-+      <option name="presentableId" value="LOCAL-00006" />
-+      <option name="project" value="LOCAL" />
-+      <updated>1623953953357</updated>
-+    </task>
-+    <option name="localTasksCounter" value="7" />
-     <servers />
-   </component>
-   <component name="Vcs.Log.Tabs.Properties">
-@@ -190,7 +196,8 @@
-     <MESSAGE value="Error sign up" />
-     <MESSAGE value="model.SpellCard.java&#10;Monster Reborn + Terraforming" />
-     <MESSAGE value="model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED" />
--    <option name="LAST_COMMIT_MESSAGE" value="model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED" />
-+    <MESSAGE value="spell action" />
-+    <option name="LAST_COMMIT_MESSAGE" value="spell action" />
-   </component>
-   <component name="WindowStateProjectService">
-     <state width="1237" height="170" key="GridCell.Tab.0.bottom" timestamp="1623766526113">
-@@ -225,10 +232,10 @@
-       <screen x="0" y="0" width="1280" height="680" />
-     </state>
-     <state x="121" y="0" key="SettingsEditor/0.0.1280.680@0.0.1280.680" timestamp="1623148484919" />
--    <state x="233" y="74" key="Vcs.Push.Dialog.v2" timestamp="1623946400386">
-+    <state x="233" y="74" key="Vcs.Push.Dialog.v2" timestamp="1623953955368">
-       <screen x="0" y="0" width="1280" height="680" />
-     </state>
--    <state x="233" y="74" key="Vcs.Push.Dialog.v2/0.0.1280.680@0.0.1280.680" timestamp="1623946400386" />
-+    <state x="233" y="74" key="Vcs.Push.Dialog.v2/0.0.1280.680@0.0.1280.680" timestamp="1623953955368" />
-     <state x="247" y="0" key="com.intellij.openapi.editor.actions.MultiplePasteAction$ClipboardContentChooser" timestamp="1623936514260">
-       <screen x="0" y="0" width="1280" height="680" />
-     </state>
-Index: src/main/java/model/SpellCard.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package model;\r\n\r\nimport controller.DuelController;\r\nimport view.DuelView;\r\n\r\nimport java.util.List;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic enum SpellCard implements Cardable {\r\n\r\n\r\n    MONSTER_REBORN(Icon.NORMAL, \"Target 1 monster in either GY; Special Summon it.\", Status.UNLIMITED, 2000) {\r\n        public boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {\r\n            if (takeActionCase.equals(TakeActionCase.PUT_IN_SPELLTRAPZONE)) {\r\n                DuelView.printText(\"enter \\\"My\\\" or \\\"Rival\\\" to select graveyard\");\r\n                String graveyard = DuelView.scan();\r\n                while (!graveyard.equals(\"cancel\") && !graveyard.equals(\"My\") && !graveyard.equals(\"Rival\")) {\r\n                    DuelView.printText(\"enter \\\"My\\\" or \\\"Rival\\\" to select graveyard\");\r\n                    graveyard = DuelView.scan();\r\n                }\r\n                switch (graveyard) {\r\n                    case \"My\":\r\n                        boolean hasMonster = false;\r\n                        for (int i = 1; i <= duelController.getPlayer().getBoard().getCardsInGraveyard().size(); i++) {\r\n                            Cardable card = duelController.getPlayer().getBoard().getCardsInGraveyard().get(i);\r\n                            if (card instanceof MonsterCard) {\r\n                                hasMonster = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!hasMonster) {\r\n                            duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n                            return true;\r\n                        }\r\n                        DuelView.printText(\"select one these cards by number:\");\r\n                        int monsterCounter = 1;\r\n                        for (int i = 1; i <= duelController.getPlayer().getBoard().getCardsInGraveyard().size(); i++) {\r\n                            Cardable card = duelController.getPlayer().getBoard().getCardsInGraveyard().get(i);\r\n                            if (card instanceof MonsterCard) {\r\n                                DuelView.printText(monsterCounter + \": \" + card.getNamePascalCase() + \": \" + card.getDescription());\r\n                                monsterCounter++;\r\n                                break;\r\n                            }\r\n                        }\r\n                        String cardNumber = DuelView.scan();\r\n                        if (cardNumber.equals(\"cancel\")) return false;\r\n                        while (!cardNumber.matches(\"\\\\d+\") || Integer.parseInt(cardNumber) < 1\r\n                                || Integer.parseInt(cardNumber) > monsterCounter - 1) {\r\n                            DuelView.printText(\"please Enter a valid Number!\");\r\n                            cardNumber = DuelView.scan();\r\n                            if (cardNumber.equals(\"cancel\")) return false;\r\n                        }\r\n                        monsterCounter = 1;\r\n                        int i;\r\n                        for (i = 1; i <= duelController.getPlayer().getBoard().getCardsInGraveyard().size(); i++) {\r\n                            Cardable card = duelController.getPlayer().getBoard().getCardsInGraveyard().get(i);\r\n                            if (card instanceof MonsterCard) {\r\n                                if (monsterCounter == Integer.parseInt(cardNumber))\r\n                                    break;\r\n                                else\r\n                                    monsterCounter++;\r\n                            }\r\n                        }\r\n                        Cardable card = duelController.getPlayer().getBoard().getCardsInGraveyard().get(i - 1);\r\n                        DuelView.printText(\"enter the position you want to summon monster in(attack or defence)\");\r\n                        String position = DuelView.scan();\r\n                        if (position.equals(\"cancel\")) return false;\r\n                        while (!(position.equals(\"attack\") || position.equals(\"defence\"))) {\r\n                            DuelView.printText(\"please enter a valid position!\");\r\n                            position = DuelView.scan();\r\n                            if (position.equals(\"cancel\")) return false;\r\n                        }\r\n                        switch (position) {\r\n                            case \"attack\":\r\n                                position = \"OO\";\r\n                                break;\r\n                            case \"defence\":\r\n                                position = \"DO\";\r\n                                break;\r\n                        }\r\n                        int targetPlace = duelController.getPlayer().getBoard().putMonster((MonsterCard) card, position);\r\n                        ((MonsterCard) card).takeAction(duelController, TakeActionCase.PUT_IN_MONSTERZONE, duelController.getPlayer(), targetPlace);\r\n                        duelController.getPlayer().getBoard().getCardsInGraveyard().remove(i - 1);\r\n                        duelController.setSelectedCard(null);\r\n                        DuelView.printText(\"special summoned successfully\");\r\n                        duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n                        return true;\r\n                    case \"Rival\":\r\n                        hasMonster = false;\r\n                        for (i = 1; i <= duelController.getRival().getBoard().getCardsInGraveyard().size(); i++) {\r\n                            card = duelController.getRival().getBoard().getCardsInGraveyard().get(i);\r\n                            if (card instanceof MonsterCard) {\r\n                                hasMonster = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!hasMonster) {\r\n                            duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n                            return true;\r\n                        }\r\n                        DuelView.printText(\"select one these cards by number:\");\r\n                        monsterCounter = 1;\r\n                        for (i = 1; i <= duelController.getRival().getBoard().getCardsInGraveyard().size(); i++) {\r\n                            card = duelController.getRival().getBoard().getCardsInGraveyard().get(i);\r\n                            if (card instanceof MonsterCard) {\r\n                                DuelView.printText(monsterCounter + \": \" + card.getNamePascalCase() + \": \" + card.getDescription());\r\n                                monsterCounter++;\r\n                                break;\r\n                            }\r\n                        }\r\n                        cardNumber = DuelView.scan();\r\n                        if (cardNumber.equals(\"cancel\")) return false;\r\n                        while (!cardNumber.matches(\"\\\\d+\") || Integer.parseInt(cardNumber) < 1\r\n                                || Integer.parseInt(cardNumber) > monsterCounter - 1) {\r\n                            DuelView.printText(\"please Enter a valid Number!\");\r\n                            cardNumber = DuelView.scan();\r\n                            if (cardNumber.equals(\"cancel\")) return false;\r\n                        }\r\n                        monsterCounter = 1;\r\n                        for (i = 1; i <= duelController.getRival().getBoard().getCardsInGraveyard().size(); i++) {\r\n                            card = duelController.getRival().getBoard().getCardsInGraveyard().get(i);\r\n                            if (card instanceof MonsterCard) {\r\n                                if (monsterCounter == Integer.parseInt(cardNumber))\r\n                                    break;\r\n                                else\r\n                                    monsterCounter++;\r\n                            }\r\n                        }\r\n                        card = duelController.getRival().getBoard().getCardsInGraveyard().get(i - 1);\r\n                        DuelView.printText(\"enter the position you want to summon monster in(attack or defence)\");\r\n                        position = DuelView.scan();\r\n                        if (position.equals(\"cancel\")) return false;\r\n                        while (!(position.equals(\"attack\") || position.equals(\"defence\"))) {\r\n                            DuelView.printText(\"please enter a valid position!\");\r\n                            position = DuelView.scan();\r\n                            if (position.equals(\"cancel\")) return false;\r\n                        }\r\n                        switch (position) {\r\n                            case \"attack\":\r\n                                position = \"OO\";\r\n                                break;\r\n                            case \"defence\":\r\n                                position = \"DO\";\r\n                                break;\r\n                        }\r\n                        targetPlace = duelController.getRival().getBoard().putMonster((MonsterCard) card, position);\r\n                        ((MonsterCard) card).takeAction(duelController, TakeActionCase.PUT_IN_MONSTERZONE, duelController.getPlayer(), targetPlace);\r\n                        duelController.getRival().getBoard().getCardsInGraveyard().remove(i - 1);\r\n                        duelController.setSelectedCard(null);\r\n                        DuelView.printText(\"special summoned successfully\");\r\n                        duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n                        return true;\r\n                    default:\r\n                        return false;\r\n                }\r\n            } else return true;\r\n        }\r\n    },\r\n\r\n    TERRAFORMING(Icon.NORMAL, \"Add 1 Field Spell from your Deck to your hand.\", Status.LIMITED, 2500) {\r\n        public boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {\r\n            if (takeActionCase.equals(TakeActionCase.PUT_IN_SPELLTRAPZONE)) {\r\n                boolean hasFieldSpell = false;\r\n                for (Cardable card : duelController.getPlayer().getGameDeck().getMainDeck()) {\r\n                    if (card instanceof SpellCard && ((SpellCard) card).getIcon().equals(Icon.FIELD)) {\r\n                        hasFieldSpell = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!hasFieldSpell) {\r\n                    duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n                    return true;\r\n                }\r\n                DuelView.printText(\"select one of these Field Spell cards from your deck to add to your hand:\");\r\n                int cardCounter = 1;\r\n                for (Cardable card : duelController.getPlayer().getGameDeck().getMainDeck()) {\r\n                    if (card instanceof SpellCard && ((SpellCard) card).getIcon().equals(Icon.FIELD)) {\r\n                        DuelView.printText(cardCounter + \": \" + card.getName() + \": \" + card.getDescription());\r\n                        cardCounter++;\r\n                    }\r\n                }\r\n                String choice = DuelView.scan();\r\n                if (choice.equals(\"cancel\")) return false;\r\n                while (!choice.matches(\"\\\\d+\") || Integer.parseInt(choice) < 1\r\n                        || Integer.parseInt(choice) > cardCounter - 1) {\r\n                    DuelView.printText(\"please Enter a valid Number!\");\r\n                    choice = DuelView.scan();\r\n                    if (choice.equals(\"cancel\")) return false;\r\n                }\r\n                cardCounter = 1;\r\n                int i;\r\n                for (i = 1; i <= duelController.getPlayer().getBoard().getCardsInGraveyard().size(); i++) {\r\n                    Cardable card = duelController.getPlayer().getBoard().getCardsInGraveyard().get(i);\r\n                    if (card instanceof SpellCard && ((SpellCard) card).getIcon().equals(Icon.FIELD)) {\r\n                        if (cardCounter == Integer.parseInt(choice))\r\n                            break;\r\n                        else\r\n                            cardCounter++;\r\n                    }\r\n                }\r\n                Cardable card = duelController.getPlayer().getGameDeck().getMainDeck().get(i - 1);\r\n                duelController.getPlayer().getBoard().getCardsInHand().add(card);\r\n                duelController.getPlayer().getGameDeck().getMainDeck().remove(i - 1);\r\n                duelController.setSelectedCard(null);\r\n                DuelView.printText(\"card added to hand successfully\");\r\n                duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n\r\n    POT_OF_GREED(Icon.NORMAL, \"Draw 2 cards.\", Status.LIMITED, 2500) {\r\n        public boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {\r\n            if (takeActionCase.equals(TakeActionCase.PUT_IN_SPELLTRAPZONE)) {\r\n                List<Cardable> deck = duelController.getPlayer().getGameDeck().getMainDeck();\r\n                Cardable card1 = deck.get(deck.size() - 1);\r\n                Cardable card2 = deck.get(deck.size() - 2);\r\n                duelController.getPlayer().getBoard().getCardsInHand().add(card1);\r\n                duelController.getPlayer().getBoard().getCardsInHand().add(card2);\r\n                deck.remove(card1);\r\n                deck.remove(card2);\r\n                DuelView.printText(\"Spell activated successfully\");\r\n                duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n\r\n    RAIGEKI(Icon.NORMAL, \"Destroy all monsters your opponent controls.\", Status.LIMITED, 2500) {\r\n        public boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {\r\n            if (takeActionCase.equals(TakeActionCase.PUT_IN_SPELLTRAPZONE)) {\r\n                for (int i = 0; i < 5; i++) {\r\n                    if(duelController.getPlayer().getBoard().getMonsterByNumber(i)!=null) {\r\n                        duelController.getPlayer().getBoard().getMonsterByNumber(i).takeAction(duelController, TakeActionCase.REMOVE_FROM_MONSTERZONE, duelController.getRival(), i);\r\n                        duelController.getPlayer().getBoard().removeMonster(i);\r\n                        duelController.setMonsterAttackRival(i, null);\r\n                    }\r\n                }\r\n                duelController.getPlayer().getBoard().removeSpellOrTrap(targetNumber);\r\n            }\r\n            return true;\r\n        }\r\n    },\r\n\r\n    CHANGE_OF_HEART(Icon.NORMAL, \"Target 1 monster your opponent controls; take control of it until the End Phase.\",\r\n            Status.LIMITED, 2500),\r\n\r\n    HARPIES_FEATHER_DUST(Icon.NORMAL, \"Destroy all Spells and Traps your opponent controls.\", Status.LIMITED, 2500),\r\n\r\n    SWORD_OF_REVEALING_LIGHT(Icon.NORMAL, \"After this card's activation, it remains on the field, but destroy \" +\r\n            \"it during the End Phase of your opponent's 3rd turn. When this card is activated: If your opponent controls\" +\r\n            \" a face-down monster, flip all monsters they control face-up. While this card is face-up on the field, your\" +\r\n            \" opponent's monsters cannot declare an attack.\", Status.UNLIMITED, 2500),\r\n\r\n    DARK_HOLE(Icon.NORMAL, \"Destroy all monsters on the field.\", Status.UNLIMITED, 2500),\r\n\r\n    SUPPLY_SQUAD(Icon.CONTINUOUS, \"Once per turn, if a monster(s) you control is destroyed by battle or card\" +\r\n            \" effect: Draw 1 card.\", Status.UNLIMITED, 4000),\r\n\r\n    SPELL_ABSORPTION(Icon.CONTINUOUS, \"Each time a Spell Card is activated, gain 500 Life Points immediately \" +\r\n            \"after it resolves.\", Status.UNLIMITED, 4000),\r\n\r\n    MESSENGER_OF_PEACE(Icon.CONTINUOUS, \"Monsters with 1500 or more ATK cannot declare an attack. Once per turn,\" +\r\n            \" during your Standby Phase, pay 100 LP or destroy this card.\", Status.UNLIMITED, 4000),\r\n\r\n    TWIN_TWISTER(Icon.QUICK_PLAY, \"Discard 1 card, then target up to 2 Spells/Traps on the field; destroy them.\"\r\n            , Status.UNLIMITED, 3500),\r\n\r\n    MYSTICAL_SPCAE_TYPHOON(Icon.QUICK_PLAY, \"Target 1 Spell/Trap on the field; destroy that target.\",\r\n            Status.UNLIMITED, 3500),\r\n\r\n    RING_OF_DEFENSE(Icon.QUICK_PLAY, \"When a Trap effect that inflicts damage is activated: Make that effect \" +\r\n            \"damage 0.\", Status.UNLIMITED, 3500),\r\n\r\n    YAMI(Icon.FIELD, \"All Fiend and Spellcaster monsters on the field gain 200 ATK/DEF, also all Fairy monsters\" +\r\n            \" on the field lose 200 ATK/DEF.\", Status.UNLIMITED, 4300),\r\n\r\n    FOREST(Icon.FIELD, \"All Insect, Beast, Plant, and Beast-Warrior monsters on the field gain 200 ATK/DEF.\",\r\n            Status.UNLIMITED, 4300),\r\n\r\n    CLOSED_FOREST(Icon.FIELD, \"All Beast-Type monsters you control gain 100 ATK for each monster in your \" +\r\n            \"Graveyard. Field Spell Cards cannot be activated. Field Spell Cards cannot be activated during the turn \" +\r\n            \"this card is destroyed.\", Status.UNLIMITED, 4300),\r\n\r\n    UMIIRUKA(Icon.FIELD, \"Increase the ATK of all WATER monsters by 500 points and decrease their DEF by 400 \" +\r\n            \"points.\", Status.UNLIMITED, 4300),\r\n\r\n    SWORD_OF_DARK_DESTRUCTION(Icon.EQUIP, \"A DARK monster equipped with this card increases its ATK by 400 \" +\r\n            \"points and decreases its DEF by 200 points.\", Status.UNLIMITED, 4300),\r\n\r\n    BLACK_PENDANT(Icon.EQUIP, \"The equipped monster gains 500 ATK. When this card is sent from the field to the\" +\r\n            \" Graveyard: Inflict 500 damage to your opponent.\", Status.UNLIMITED, 4300),\r\n\r\n    UNITED_WE_STAND(Icon.EQUIP, \"The equipped monster gains 800 ATK/DEF for each face-up monster you control.\",\r\n            Status.UNLIMITED, 4300),\r\n\r\n    MAGNUM_SHIELD(Icon.EQUIP, \"Equip only to a Warrior-Type monster. Apply this effect, depending on its battle position.\\n\" +\r\n            \"Attack Position: It gains ATK equal to its original DEF.\\n\" +\r\n            \"Defense Position: It gains DEF equal to its original ATK.\", Status.UNLIMITED, 4300),\r\n\r\n    ADVANCED_RITUAL_ART(Icon.RITUAL, \"This card can be used to Ritual Summon any 1 Ritual Monster. You must \" +\r\n            \"also send Normal Monsters from your Deck to the Graveyard whose total Levels equal the Level of that Ritual\" +\r\n            \" Monster.\", Status.UNLIMITED, 3000);\r\n\r\n\r\n    private final Icon icon;\r\n    private final Status status;\r\n    private final String description;\r\n    private final int price;\r\n\r\n    SpellCard(Icon icon, String description, Status status, int price) {\r\n        this.icon = icon;\r\n        this.status = status;\r\n        this.description = description;\r\n        this.price = price;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return this.description;\r\n    }\r\n\r\n    public int getPrice() {\r\n        return this.price;\r\n    }\r\n\r\n    public Icon getIcon() {\r\n        return this.icon;\r\n    }\r\n\r\n    public Status getStatus() {\r\n        return this.status;\r\n    }\r\n\r\n    public String getName() {\r\n        return this.name();\r\n    }\r\n\r\n    public abstract boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber);\r\n\r\n    public String getNamePascalCase() {\r\n        String name = this.name().charAt(0) + this.name().substring(1).toLowerCase();\r\n        Pattern pattern = Pattern.compile(\"_([a-z])[a-z]+\");\r\n        Matcher matcher = pattern.matcher(name);\r\n        while (matcher.find())\r\n            name = name.replace(\"_\" + matcher.group(1), \"_\" + matcher.group(1).toUpperCase());\r\n        name = name.replaceAll(\"_\", \" \");\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String name = this.getNamePascalCase();\r\n        String toReturn = \"Name: \" + name + \"\\n\" +\r\n                \"Spell\" + \"\\n\";\r\n        String type = this.icon.getNamePascalCase();\r\n        toReturn = toReturn + \"Type: \" + type + \"\\n\" +\r\n                \"Description: \" + this.description;\r\n        return toReturn;\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
---- src/main/java/model/SpellCard.java	(revision 7f7108b19f275a68ca32b60240f17cc8f3739458)
-+++ src/main/java/model/SpellCard.java	(date 1624001818675)
-@@ -231,7 +231,7 @@
-         public boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {
-             if (takeActionCase.equals(TakeActionCase.PUT_IN_SPELLTRAPZONE)) {
-                 for (int i = 0; i < 5; i++) {
--                    if(duelController.getPlayer().getBoard().getMonsterByNumber(i)!=null) {
-+                    if (duelController.getPlayer().getBoard().getMonsterByNumber(i) != null) {
-                         duelController.getPlayer().getBoard().getMonsterByNumber(i).takeAction(duelController, TakeActionCase.REMOVE_FROM_MONSTERZONE, duelController.getRival(), i);
-                         duelController.getPlayer().getBoard().removeMonster(i);
-                         duelController.setMonsterAttackRival(i, null);
-@@ -274,7 +274,62 @@
-             "damage 0.", Status.UNLIMITED, 3500),
- 
-     YAMI(Icon.FIELD, "All Fiend and Spellcaster monsters on the field gain 200 ATK/DEF, also all Fairy monsters" +
--            " on the field lose 200 ATK/DEF.", Status.UNLIMITED, 4300),
-+            " on the field lose 200 ATK/DEF.", Status.UNLIMITED, 4300){
-+        public boolean takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {
-+            if(takeActionCase.equals(TakeActionCase.PUT_IN_FIELDZONE_FACE_UP)){
-+                for (int i = 0; i < 5; i++) {
-+                    MonsterCard playerMonster = duelController.getPlayer().getBoard().getMonsterByNumber(i);
-+                    MonsterCard rivalMonster = duelController.getRival().getBoard().getMonsterByNumber(i);
-+                    if(playerMonster!=null){
-+                        if(playerMonster.getMonsterType().equals(MonsterType.FIEND) || playerMonster.getMonsterType().equals(MonsterType.SPELLCASTER)){
-+                            duelController.changePlayerAttackPoint(i,200);
-+                            duelController.changePlayerDefencePoint(i,200);
-+                        }
-+                        else if(playerMonster.getMonsterType().equals(MonsterType.FAIRY)){
-+                            duelController.changePlayerAttackPoint(i,-200);
-+                            duelController.changePlayerDefencePoint(i,-200);
-+                        }
-+                    }
-+                    if(rivalMonster!=null){
-+                        if(rivalMonster.getMonsterType().equals(MonsterType.FIEND) || rivalMonster.getMonsterType().equals(MonsterType.SPELLCASTER)){
-+                            duelController.changeRivalAttackPoint(i,200);
-+                            duelController.changeRivalDefencePoint(i,200);
-+                        }
-+                        else if(rivalMonster.getMonsterType().equals(MonsterType.FAIRY)){
-+                            duelController.changeRivalAttackPoint(i,-200);
-+                            duelController.changeRivalDefencePoint(i,-200);
-+                        }
-+                    }
-+                }
-+            }
-+            else if(takeActionCase.equals(TakeActionCase.REMOVE_FROM_FIELDZONE_FACE_UP)){
-+                for (int i = 0; i < 5; i++) {
-+                    MonsterCard playerMonster = duelController.getPlayer().getBoard().getMonsterByNumber(i);
-+                    MonsterCard rivalMonster = duelController.getRival().getBoard().getMonsterByNumber(i);
-+                    if(playerMonster!=null){
-+                        if(playerMonster.getMonsterType().equals(MonsterType.FIEND) || playerMonster.getMonsterType().equals(MonsterType.SPELLCASTER)){
-+                            duelController.changePlayerAttackPoint(i,-200);
-+                            duelController.changePlayerDefencePoint(i,-200);
-+                        }
-+                        else if(playerMonster.getMonsterType().equals(MonsterType.FAIRY)){
-+                            duelController.changePlayerAttackPoint(i,200);
-+                            duelController.changePlayerDefencePoint(i,200);
-+                        }
-+                    }
-+                    if(rivalMonster!=null){
-+                        if(rivalMonster.getMonsterType().equals(MonsterType.FIEND) || rivalMonster.getMonsterType().equals(MonsterType.SPELLCASTER)){
-+                            duelController.changeRivalAttackPoint(i,-200);
-+                            duelController.changeRivalDefencePoint(i,-200);
-+                        }
-+                        else if(rivalMonster.getMonsterType().equals(MonsterType.FAIRY)){
-+                            duelController.changeRivalAttackPoint(i,200);
-+                            duelController.changeRivalDefencePoint(i,200);
-+                        }
-+                    }
-+                }
-+            }
-+        }
-+    },
- 
-     FOREST(Icon.FIELD, "All Insect, Beast, Plant, and Beast-Warrior monsters on the field gain 200 ATK/DEF.",
-             Status.UNLIMITED, 4300),
Index: src/main/java/controller/ImportExportUserController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport controller.exeption.RepetitiveNickname;\r\nimport controller.exeption.RepetitiveUsername;\r\nimport model.Cardable;\r\nimport model.Deck;\r\nimport model.User;\r\n\r\nimport javax.smartcardio.Card;\r\nimport java.io.*;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\npublic class ImportExportUserController {\r\n    private static ImportExportUserController instance = null;\r\n\r\n    public static ImportExportUserController getInstance() {\r\n        if (instance == null) instance = new ImportExportUserController();\r\n        return instance;\r\n    }\r\n\r\n    public void exportNewUser(User user) {\r\n        if (user != null) {\r\n            String username = user.getUsername();\r\n            String password = user.getPassword();\r\n            String nickname = user.getNickname();\r\n            int highScore = user.getScore();\r\n            int balance = user.getMoney();\r\n            try {\r\n                FileWriter writer = new FileWriter(\"Users/\" + username + \".txt\");\r\n                writer.write(username + \"\\n\" + password + \"\\n\" + nickname + \"\\n\" + highScore + \"\\n\" + balance);\r\n                writer.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public void exportAllUsers(List<User> allUsers) {\r\n        try {\r\n            FileWriter writer = new FileWriter(\"allUsers.txt\");\r\n            for (User user : allUsers) {\r\n                String username = user.getUsername();\r\n                writer.write(username + \"\\n\");\r\n            }\r\n            writer.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void importAllUsers() {\r\n        String username = \"\";\r\n        String password = \"\";\r\n        String nickname = \"\";\r\n        String highScore = \"\";\r\n        String balance = \"\";\r\n        File file = new File(\"allUsers.txt\");\r\n        try {\r\n            if (file.exists()) {\r\n                Scanner scanner = new Scanner(file);\r\n                while (scanner.hasNextLine()) {\r\n                    username = scanner.nextLine();\r\n                    File userFile = new File(\"Users/\" + username + \".txt\");\r\n                    Scanner userScanner = new Scanner(userFile);\r\n                    int counter = 5;\r\n                    while (userScanner.hasNextLine()) {\r\n                        if (counter == 5)\r\n                            username = userScanner.nextLine();\r\n                        if (counter == 4)\r\n                            password = userScanner.nextLine();\r\n                        if (counter == 3)\r\n                            nickname = userScanner.nextLine();\r\n                        if (counter == 2)\r\n                            highScore = userScanner.nextLine();\r\n                        if (counter == 1)\r\n                            balance = userScanner.nextLine();\r\n                        if (counter == 0)\r\n                            break;\r\n                        counter--;\r\n                    }\r\n                    User user = new User(username, nickname, password);\r\n                    if (balance.matches(\"\\\\d+\") && highScore.matches(\"\\\\d+\")) {\r\n                        user.setMoney(Integer.parseInt(balance));\r\n                        user.setScore(Integer.parseInt(highScore));\r\n                    }\r\n                }\r\n            }\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void exportAllDecksName(List<Deck> allDecks, User user) {\r\n        String username = user.getUsername();\r\n        try {\r\n            FileWriter fileWriter = new FileWriter(\"UsersDecks/\" + username + \"AllDecks.txt\");\r\n            for (Deck deck : allDecks) {\r\n                String deckName = deck.getDeckName();\r\n                fileWriter.write(deckName + \"\\n\");\r\n            }\r\n            fileWriter.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void exportCardsInMainDeck(User user, String deckName) {\r\n        String username = user.getUsername();\r\n        try {\r\n            FileWriter writer = new FileWriter(\"Deck/\" + username + deckName + \"MainDeck.txt\");\r\n            Deck toBeExportedDeck = user.getDeckByName(deckName);\r\n            for (Cardable card : toBeExportedDeck.getMainDeck()) {\r\n                String cardName = card.getName();\r\n                writer.write(cardName + \"\\n\");\r\n            }\r\n            writer.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void exportCardsInSideDeck(User user, String deckName) {\r\n        String username = user.getUsername();\r\n        try {\r\n            FileWriter writer = new FileWriter(\"Deck/\" + username + deckName + \"SideDeck.txt\");\r\n            Deck toBeExportedDeck = user.getDeckByName(deckName);\r\n            for (Cardable card : toBeExportedDeck.getSideDeck()) {\r\n                String cardName = card.getName();\r\n                writer.write(cardName + \"\\n\");\r\n            }\r\n            writer.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void importAllDecks() {\r\n        if (User.getAllUsers() != null) {\r\n            for (User user : User.getAllUsers()) {\r\n                String username = user.getUsername();\r\n                File file = new File(\"UsersDecks/\" + username + \"AllDecks.txt\");\r\n                String deckName;\r\n                try {\r\n                    if (file.exists()) {\r\n                        Scanner scanner = new Scanner(file);\r\n                        while (scanner.hasNextLine()) {\r\n                            deckName = scanner.nextLine();\r\n                            File mainDeckFile = new File(\"Deck/\" + user.getUsername() + deckName + \"MainDeck.txt\");\r\n                            File sideDeckFile = new File(\"Deck/\" + user.getUsername() + deckName + \"SideDeck.txt\");\r\n                            if (mainDeckFile.exists()) {\r\n                                Scanner mainDeckScanner = new Scanner(mainDeckFile);\r\n                                Deck deck = new Deck(deckName);\r\n                                while (mainDeckScanner.hasNextLine()) {\r\n                                    String cardName = mainDeckScanner.nextLine();\r\n                                    deck.addCardToMainDeck(DeckController.getInstance(user).getCardByName(cardName));\r\n                                }\r\n                                user.addDeck(deck);\r\n                            }\r\n                            if (sideDeckFile.exists()) {\r\n                                Scanner sideDeckScanner = new Scanner(sideDeckFile);\r\n                                Deck deck = new Deck(deckName);\r\n                                while (sideDeckScanner.hasNextLine()) {\r\n                                    String cardName = sideDeckScanner.nextLine();\r\n                                    deck.addCardToSideDeck(DeckController.getInstance(user).getCardByName(cardName));\r\n                                }\r\n                                user.addDeck(deck);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (FileNotFoundException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void exportAllCards(User user) {\r\n        try {\r\n            FileWriter writer = new FileWriter(\"Cards/\" + user.getUsername() + \".txt\");\r\n            for (Cardable card : user.getAllCards()) {\r\n                String cardName = card.getName();\r\n                writer.write(cardName + \"\\n\");\r\n            }\r\n            writer.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void importAllCards() {\r\n        if (User.getAllUsers() != null) {\r\n            for (User user : User.getAllUsers()) {\r\n                String username = user.getUsername();\r\n                File file = new File(\"Cards/\" + username + \".txt\");\r\n                if (file.exists()) {\r\n                    try {\r\n                        Scanner scanner = new Scanner(file);\r\n                        while (scanner.hasNextLine()) {\r\n                            String cardName = scanner.nextLine();\r\n                            user.addCardToUsersAllCards(DeckController.getInstance(user).getCardByName(cardName));\r\n                        }\r\n                    } catch (FileNotFoundException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/controller/ImportExportUserController.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/controller/ImportExportUserController.java	(date 1624607871520)
@@ -211,4 +211,4 @@
             }
         }
     }
-}
\ No newline at end of file
+}
Index: src/main/java/view/MainView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package view;\r\n\r\nimport controller.DeckController;\r\nimport controller.MainController;\r\nimport controller.ShopController;\r\nimport model.*;\r\n\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\npublic class MainView {\r\n    private static MainView instance = null;\r\n    private User user;\r\n\r\n    public static MainView getInstance(User user) {\r\n        if (instance == null) instance = new MainView(user);\r\n        else if (!instance.user.equals(user)) instance.user = user;\r\n        return instance;\r\n    }\r\n\r\n    private MainView(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public void getCommandForMain() {\r\n        String command;\r\n        while (ScannerClassForView.getScanner().hasNext()) {\r\n            command = ScannerClassForView.getScanner().nextLine();\r\n            if (processCommand(command)) break;\r\n        }\r\n        printText(\"user logged out successfully!\");\r\n    }\r\n\r\n    private boolean processCommand(String command) {\r\n        MainController mainController = MainController.getInstance(this.user);\r\n        if (command.startsWith(\"duel \") && command.matches(\"[\\\\w -]+\")) {\r\n            Matcher matcher1 = getCommandMatcher(command, \"(--new|-n)\");\r\n            Matcher matcher2 = getCommandMatcher(command+\" \", \"(--second-player|-sp) ([\\\\w ]+) \");\r\n            Matcher matcher3 = getCommandMatcher(command, \"(--rounds|-r) ([0-9]+)\");\r\n            Matcher matcher4 = getCommandMatcher(command, \"(--ai|-ai)\");\r\n            if (matcher1.find() && matcher2.find() && matcher3.find()) {\r\n                try {\r\n                    mainController.newDuel(matcher2.group(2), Integer.parseInt(matcher3.group(2)));\r\n                }\r\n                catch (Exception exception){\r\n                    printText(exception.getMessage());\r\n                }\r\n                return false;\r\n            }\r\n            if(matcher4.find() && matcher1.find() && matcher3.find()){\r\n                try{\r\n                    new User(\"@AI@\",\"@AIplayer\",\"1234AIPlayer1234\");\r\n                    User.getUserByUsername(\"@AI@\").setActiveDeck(DeckController.getInstance(User.getUserByUsername(\"@AI@\")).createRandomDeckForAI());\r\n                    mainController.newDuel(\"@AI@\",Integer.parseInt(matcher3.group(2)));\r\n                }\r\n                catch (Exception exception){\r\n                    printText(exception.getMessage());\r\n                }\r\n            }\r\n\r\n            Matcher matcher = getCommandMatcher(command, \"edoCtaehc yenom ([0-9]+)\");\r\n            if (matcher.matches()){\r\n                int amount = Integer.parseInt(matcher.group(1));\r\n                mainController.cheatMoney(amount);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        //TODO MENU ENTER NEMIKONE\r\n        Matcher matcher = getCommandMatcher(command, \"menu enter ([\\\\w ]+)\");\r\n        if (matcher.matches()) {\r\n            mainController.goToMenu(matcher.group(1));\r\n            return false;\r\n        }\r\n        matcher = getCommandMatcher(command, \"menu show-current\");\r\n        if (matcher.matches()) {\r\n            printText(\"Main Menu\");\r\n            return false;\r\n        }\r\n        if ((command.equals(\"user logout\"))||(command.equals(\"menu exit\"))) return true;\r\n        printText(\"invalid command\");\r\n        return false;\r\n    }\r\n\r\n    private Matcher getCommandMatcher(String command, String regex) {\r\n        Pattern pattern = Pattern.compile(regex);\r\n        return pattern.matcher(command);\r\n    }\r\n\r\n    public void printText(String output) {\r\n        System.out.println(output);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/view/MainView.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/view/MainView.java	(date 1624605458322)
@@ -57,17 +57,16 @@
                     printText(exception.getMessage());
                 }
             }
-
-            Matcher matcher = getCommandMatcher(command, "edoCtaehc yenom ([0-9]+)");
-            if (matcher.matches()){
-                int amount = Integer.parseInt(matcher.group(1));
-                mainController.cheatMoney(amount);
-                return false;
-            }
+        }
+        Matcher matcher = getCommandMatcher(command, "edoCtaehc yenom ([0-9]+)");
+        if (matcher.matches()){
+            int amount = Integer.parseInt(matcher.group(1));
+            mainController.cheatMoney(amount);
+            return false;
         }
 
-        //TODO MENU ENTER NEMIKONE
-        Matcher matcher = getCommandMatcher(command, "menu enter ([\\w ]+)");
+        //TO DO MENU ENTER NEMIKONE(mikone alan dige?parmida)
+        matcher = getCommandMatcher(command, "menu enter ([\\w ]+)");
         if (matcher.matches()) {
             mainController.goToMenu(matcher.group(1));
             return false;
Index: src/main/java/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import controller.ImportExportUserController;\r\nimport view.LogInView;\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n        importExportUserController.importAllUsers();\r\n        importExportUserController.importAllCards();\r\n        importExportUserController.importAllDecks();\r\n        LogInView.getInstance().getCommandForLogin();\r\n        /*ArrayList<MonsterTypes> types = new ArrayList<>();\r\n        types.add(MonsterTypes.BEAST);\r\n        types.add(MonsterTypes.CYBERSE);\r\n        types.add(MonsterTypes.BEAST_WARRIOR);\r\n        String typesForPrint;\r\n        for(MonsterTypes eachType : types){\r\n            typesForPrint += eachType.toString().\r\n        }\r\n        String typesForPrint = types.toString().replaceAll(\"\\\\[|\\\\]\",\"\").replaceAll(\", \",\"/\").replaceAll(\"_\",\"-\");\r\n        System.out.println(typesForPrint);\r\n        System.out.println(MonsterType.AQUA);\r\n        String test = \"HELLO_WELCOME_TO_HERE\";\r\n        test = test.charAt(0) + test.substring(1).toLowerCase();\r\n        Pattern pattern = Pattern.compile(\"_([a-z])[a-z]+\");\r\n        Matcher matcher = pattern.matcher(test);\r\n        while (matcher.find())\r\n            test = test.replace(matcher.group(1), matcher.group(1).toUpperCase());\r\n        test = test.replaceAll(\"_\",\" \");\r\n        System.out.println(test);\r\n        System.out.println(Model.Icon.EQUIP);\r\n        System.out.println(MonsterCard.BATTLE_OX.getAttribute());\r\n        Deck deck = new Deck(\"me\");\r\n        Deck deck1 = new Deck(\"ey\");\r\n        Deck deck2 = new Deck(\"mo\");\r\n        ArrayList<Deck> allDecks = new ArrayList<>();\r\n        allDecks.add(deck);\r\n        allDecks.add(deck1);\r\n        allDecks.add(deck2);\r\n        Comparator<Deck> deckComparator = Comparator.comparing(Deck::getDeckName);\r\n        allDecks.sort(deckComparator);\r\n        System.out.println(allDecks);*/\r\n    }\r\n}\r\n/*\r\nuser login -u hamraz -p 123\r\nmenu enter Shop\r\nshop buy Yomi Ship\r\nshop buy Yomi Ship\r\nshop buy Yomi Ship\r\nshop buy Wattaildragon\r\nshop buy Wattaildragon\r\nshop buy Wattaildragon\r\nshop buy Warrior Dai Grepher\r\nshop buy Warrior Dai Grepher\r\nshop buy Warrior Dai Grepher\r\nshop buy Warrior Dai Grepher\r\nshop buy Bitron\r\nshop buy Bitron\r\nshop buy Bitron\r\nshop buy Bitron\r\nshop buy Dark Hole\r\nshop buy Dark Hole\r\nshop buy Dark Hole\r\nshop buy Exploder Dragon\r\nshop buy Exploder Dragon\r\nshop buy Exploder Dragon\r\nshop buy Command Knight\r\nshop buy Command Knight\r\nshop buy Command Knight\r\nshop buy Command Knight\r\nshop buy Curtain Of Dark Ones\r\nshop buy Curtain Of Dark Ones\r\nshop buy Curtain Of Dark Ones\r\nshop buy Curtain Of Dark Ones\r\nshop buy Silver Fang\r\nshop buy Silver Fang\r\nshop buy Silver Fang\r\nshop buy Silver Fang\r\nshop buy Haniwa\r\nshop buy Haniwa\r\nshop buy Haniwa\r\nshop buy Haniwa\r\nshop buy Horn Imp\r\nshop buy Horn Imp\r\nshop buy Horn Imp\r\nshop buy Horn Imp\r\nshop buy Magic Cylinder\r\nshop buy Magic Cylinder\r\nshop buy Magic Cylinder\r\nshop buy Magic Cylinder\r\nshop buy Mind Crush\r\nshop buy Mind Crush\r\nshop buy Mind Crush\r\nshop buy Mind Crush\r\nshop buy Man Eater Bug\r\nshop buy Man Eater Bug\r\nshop buy Man Eater Bug\r\nshop buy Man Eater Bug\r\nshop buy Silver Fang\r\nshop buy Silver Fang\r\nshop buy Silver Fang\r\nshop buy Silver Fang\r\nshop buy Supply Squad\r\nshop buy Supply Squad\r\nshop buy Supply Squad\r\nshop buy Supply Squad\r\nbuy card Sword Of Revealing Light\r\nshop buy Sword Of Revealing Light\r\nshop buy Sword Of Revealing Light\r\nshop buy Sword Of Revealing Light\r\nshop buy Supply Squad\r\nshop buy Supply Squad\r\nshop buy Supply Squad\r\nshop buy Trap Hole\r\nshop buy Trap Hole\r\nshop buy Trap Hole\r\nshop buy Spell Absorption\r\nshop buy Spell Absorption\r\nshop buy Spell Absorption\r\nshop buy Leotron\r\nshop buy Leotron\r\nshop buy Leotron\r\nshop buy Leotron\r\nshop buy United We Stand\r\nshop buy United We Stand\r\nshop buy United We Stand\r\nmenu exit\r\nmenu enter Deck\r\ndeck create one\r\ndeck add-card -c United We Stand -d one\r\ndeck add-card -c United We Stand -d one\r\ndeck add-card -c United We Stand -d one\r\ndeck add-card -c United We Stand -d one\r\ndeck add-card -c Leotron -d one\r\ndeck add-card -c Leotron -d one\r\ndeck add-card -c Leotron -d one\r\ndeck add-card -c Leotron -d one\r\ndeck add-card -c Leotron -d one -s\r\ndeck add-card -c Silver Fang -d one -s\r\ndeck add-card -c Silver Fang -d one –s\r\ndeck add-card -c Silver Fang -d one -s\r\ndeck add-card -c Silver Fang -d one -s\r\ndeck add-card -c Silver Fang -d one -s\r\ndeck add-card -c Spell Absorption -d one -s\r\ndeck add-card -c Spell Absorption -d one -s\r\ndeck add-card -c Spell Absorption -d one -s\r\ndeck add-card -c Spell Absorption -d one -s\r\ndeck add-card -c Trap Hole -d one -s\r\ndeck add-card -c Trap Hole -d one -s\r\ndeck add-card -c Trap Hole -d one -s\r\ndeck add-card -c Trap Hole -d one -s\r\ndeck add-card -c shop buy Supply Squad\r\ndeck add-card -c Supply Squad -d one -s\r\ndeck add-card -c Supply Squad -d one -s\r\ndeck add-card -c Supply Squad -d one -s\r\ndeck add-card -c Sword Of Revealing Light -d one -s\r\ndeck add-card -c Sword Of Revealing Light -d one -s\r\ndeck add-card -c Sword Of Revealing Light -d one -s\r\ndeck add-card -c Sword Of Revealing Light -d one -s\r\ncard with name Sword Of Revealing Light does not exist\r\ndeck add-card -c Supply Squad -d one -s\r\ndeck add-card -c Supply Squad -d one\r\ndeck add-card -c Silver Fang -d one\r\ndeck add-card -c Man Eater Bug -d one\r\ndeck add-card -c Man Eater Bug -d one\r\ndeck add-card -c Man Eater Bug -d one\r\ndeck add-card -c Man Eater Bug -d one\r\ndeck add-card -c Mind Crush -d one\r\ndeck add-card -c Mind Crush -d one\r\ndeck add-card -c Mind Crush -d one\r\ndeck add-card -c Mind Crush -d one\r\ndeck add-card -c Magic Cylinder -d one\r\ndeck add-card -c Magic Cylinder -d one\r\ndeck add-card -c Magic Cylinder -d one\r\ndeck add-card -c Magic Cylinder -d one\r\ndeck show --all\r\ndeck add-card -c Horn Imp -d one\r\ndeck add-card -c Horn Imp -d one\r\ndeck add-card -c Horn Imp -d one\r\ndeck add-card Haniwa -d one\r\ndeck add-card -c Haniwa -d one\r\ndeck add-card -c Haniwa -d one\r\ndeck add-card -c Haniwa -d one\r\ndeck add-card -c Haniwa -d one\r\ndeck show --all\r\ndeck add-card -c Curtain Of Dark Ones -d one\r\ndeck add-card -c Curtain Of Dark Ones -d one\r\ndeck add-card -c Curtain Of Dark Ones -d one\r\ndeck add-card -c Curtain Of Dark Ones -d one\r\ndeck add-card -c Command Knight -d one\r\ndeck add-card -c Command Knight -d one\r\ndeck add-card -c Command Knight -d one\r\ndeck add-card -c Command Knight -d one\r\ndeck add-card -c Exploder Dragon -d one\r\ndeck add-card -c Exploder Dragon -d one\r\ndeck add-card -c Exploder Dragon -d one\r\ndeck add-card -c Exploder Dragon -d one\r\ndeck add-card -c Dark Hole -d one\r\ndeck add-card -c Dark Hole -d one\r\ndeck add-card -c Dark Hole -d one\r\ndeck add-card -c Dark Hole -d one\r\ndeck add-card -c Bitron -d one\r\ndeck add-card -c Bitron -d one\r\ndeck add-card -c Bitron -d one\r\ndeck add-card -c Bitron -d one\r\ndeck add-card -c Bitron -d one\r\ndeck add-card -c Warrior Dai Grepher -d one\r\ndeck add-card -c Warrior Dai Grepher -d one\r\ndeck add-card -c Warrior Dai Grepher -d one\r\ndeck add-card -c Warrior Dai Grepher -d one\r\ndeck add-card -c Wattaildragon -d one\r\ndeck add-card -c Wattaildragon -d one\r\ndeck add-card -c Wattaildragon -d one\r\ndeck show --all\r\ndeck add-card -c Yomi Ship -d one\r\ndeck add-card -c Yomi Ship -d one\r\ndeck add-card -c Yomi Ship -d one\r\ndeck add-card -c Yomi Ship -d one\r\ndeck add-card -c Yami -d one\r\ndeck add-card -c Yami -d one\r\ndeck add-card -c Yami -d one\r\ndeck add-card -c Yami -d one\r\ndeck show --all\r\nmenu exit\r\nmenu enter Shop\r\nshop buy Yami\r\nshop buy Yami\r\nmenu exit\r\nmenu enter Deck\r\ndeck add-card -c Yami -d one\r\ndeck show --all\r\nmenu exit\r\n */\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/Main.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/Main.java	(date 1624608359208)
@@ -42,7 +42,10 @@
     }
 }
 /*
+user create -u hamraz -p 123 -n hamraz
+user create -u parmida -p 1234 -n parmida
 user login -u hamraz -p 123
+edoCtaehc yenom 1000000
 menu enter Shop
 shop buy Yomi Ship
 shop buy Yomi Ship
@@ -228,6 +231,199 @@
 menu exit
 menu enter Deck
 deck add-card -c Yami -d one
+deck show –-all
+deck set-activate one
+menu exit
+user logout
+user login -u parmida -p 1234
+edoCtaehc yenom 1000000
+menu enter Shop
+shop buy Yomi Ship
+shop buy Yomi Ship
+shop buy Yomi Ship
+shop buy Wattaildragon
+shop buy Wattaildragon
+shop buy Wattaildragon
+shop buy Warrior Dai Grepher
+shop buy Warrior Dai Grepher
+shop buy Warrior Dai Grepher
+shop buy Warrior Dai Grepher
+shop buy Bitron
+shop buy Bitron
+shop buy Bitron
+shop buy Bitron
+shop buy Dark Hole
+shop buy Dark Hole
+shop buy Dark Hole
+shop buy Exploder Dragon
+shop buy Exploder Dragon
+shop buy Exploder Dragon
+shop buy Command Knight
+shop buy Command Knight
+shop buy Command Knight
+shop buy Command Knight
+shop buy Curtain Of Dark Ones
+shop buy Curtain Of Dark Ones
+shop buy Curtain Of Dark Ones
+shop buy Curtain Of Dark Ones
+shop buy Silver Fang
+shop buy Silver Fang
+shop buy Silver Fang
+shop buy Silver Fang
+shop buy Haniwa
+shop buy Haniwa
+shop buy Haniwa
+shop buy Haniwa
+shop buy Horn Imp
+shop buy Horn Imp
+shop buy Horn Imp
+shop buy Horn Imp
+shop buy Magic Cylinder
+shop buy Magic Cylinder
+shop buy Magic Cylinder
+shop buy Magic Cylinder
+shop buy Mind Crush
+shop buy Mind Crush
+shop buy Mind Crush
+shop buy Mind Crush
+shop buy Man Eater Bug
+shop buy Man Eater Bug
+shop buy Man Eater Bug
+shop buy Man Eater Bug
+shop buy Silver Fang
+shop buy Silver Fang
+shop buy Silver Fang
+shop buy Silver Fang
+shop buy Supply Squad
+shop buy Supply Squad
+shop buy Supply Squad
+shop buy Supply Squad
+buy card Sword Of Revealing Light
+shop buy Sword Of Revealing Light
+shop buy Sword Of Revealing Light
+shop buy Sword Of Revealing Light
+shop buy Supply Squad
+shop buy Supply Squad
+shop buy Supply Squad
+shop buy Trap Hole
+shop buy Trap Hole
+shop buy Trap Hole
+shop buy Spell Absorption
+shop buy Spell Absorption
+shop buy Spell Absorption
+shop buy Leotron
+shop buy Leotron
+shop buy Leotron
+shop buy Leotron
+shop buy United We Stand
+shop buy United We Stand
+shop buy United We Stand
+menu exit
+menu enter Deck
+deck create oneParmida
+deck add-card -c United We Stand -d oneParmida
+deck add-card -c United We Stand -d oneParmida
+deck add-card -c United We Stand -d oneParmida
+deck add-card -c United We Stand -d oneParmida
+deck add-card -c Leotron -d oneParmida
+deck add-card -c Leotron -d oneParmida
+deck add-card -c Leotron -d oneParmida
+deck add-card -c Leotron -d oneParmida
+deck add-card -c Leotron -d oneParmida -s
+deck add-card -c Silver Fang -d oneParmida -s
+deck add-card -c Silver Fang -d oneParmida –s
+deck add-card -c Silver Fang -d oneParmida -s
+deck add-card -c Silver Fang -d oneParmida -s
+deck add-card -c Silver Fang -d oneParmida -s
+deck add-card -c Spell Absorption -d oneParmida -s
+deck add-card -c Spell Absorption -d oneParmida -s
+deck add-card -c Spell Absorption -d oneParmida -s
+deck add-card -c Spell Absorption -d oneParmida -s
+deck add-card -c Trap Hole -d oneParmida -s
+deck add-card -c Trap Hole -d oneParmida -s
+deck add-card -c Trap Hole -d oneParmida -s
+deck add-card -c Trap Hole -d oneParmida -s
+deck add-card -c Supply Squad -d oneParmida -s
+deck add-card -c Supply Squad -d oneParmida -s
+deck add-card -c Supply Squad -d oneParmida -s
+deck add-card -c Sword Of Revealing Light -d oneParmida -s
+deck add-card -c Sword Of Revealing Light -d oneParmida -s
+deck add-card -c Sword Of Revealing Light -d oneParmida -s
+deck add-card -c Sword Of Revealing Light -d oneParmida -s
+deck add-card -c Supply Squad -d oneParmida -s
+deck add-card -c Supply Squad -d oneParmida
+deck add-card -c Silver Fang -d oneParmida
+deck add-card -c Man Eater Bug -d oneParmida
+deck add-card -c Man Eater Bug -d oneParmida
+deck add-card -c Man Eater Bug -d oneParmida
+deck add-card -c Man Eater Bug -d oneParmida
+deck add-card -c Mind Crush -d oneParmida
+deck add-card -c Mind Crush -d oneParmida
+deck add-card -c Mind Crush -d oneParmida
+deck add-card -c Mind Crush -d oneParmida
+deck add-card -c Magic Cylinder -d oneParmida
+deck add-card -c Magic Cylinder -d oneParmida
+deck add-card -c Magic Cylinder -d oneParmida
+deck add-card -c Magic Cylinder -d oneParmida
+deck show --all
+deck add-card -c Horn Imp -d oneParmida
+deck add-card -c Horn Imp -d oneParmida
+deck add-card -c Horn Imp -d oneParmida
+deck add-card Haniwa -d oneParmida
+deck add-card -c Haniwa -d oneParmida
+deck add-card -c Haniwa -d oneParmida
+deck add-card -c Haniwa -d oneParmida
+deck add-card -c Haniwa -d oneParmida
+deck show --all
+deck add-card -c Curtain Of Dark Ones -d oneParmida
+deck add-card -c Curtain Of Dark Ones -d oneParmida
+deck add-card -c Curtain Of Dark Ones -d oneParmida
+deck add-card -c Curtain Of Dark Ones -d oneParmida
+deck add-card -c Command Knight -d oneParmida
+deck add-card -c Command Knight -d oneParmida
+deck add-card -c Command Knight -d oneParmida
+deck add-card -c Command Knight -d oneParmida
+deck add-card -c Exploder Dragon -d oneParmida
+deck add-card -c Exploder Dragon -d oneParmida
+deck add-card -c Exploder Dragon -d oneParmida
+deck add-card -c Exploder Dragon -d oneParmida
+deck add-card -c Dark Hole -d oneParmida
+deck add-card -c Dark Hole -d oneParmida
+deck add-card -c Dark Hole -d oneParmida
+deck add-card -c Dark Hole -d oneParmida
+deck add-card -c Bitron -d oneParmida
+deck add-card -c Bitron -d oneParmida
+deck add-card -c Bitron -d oneParmida
+deck add-card -c Bitron -d oneParmida
+deck add-card -c Bitron -d oneParmida
+deck add-card -c Warrior Dai Grepher -d oneParmida
+deck add-card -c Warrior Dai Grepher -d oneParmida
+deck add-card -c Warrior Dai Grepher -d oneParmida
+deck add-card -c Warrior Dai Grepher -d oneParmida
+deck add-card -c Wattaildragon -d oneParmida
+deck add-card -c Wattaildragon -d oneParmida
+deck add-card -c Wattaildragon -d oneParmida
+deck show --all
+deck add-card -c Yomi Ship -d oneParmida
+deck add-card -c Yomi Ship -d oneParmida
+deck add-card -c Yomi Ship -d oneParmida
+deck add-card -c Yomi Ship -d oneParmida
+deck add-card -c Yami -d oneParmida
+deck add-card -c Yami -d oneParmida
+deck add-card -c Yami -d oneParmida
+deck add-card -c Yami -d oneParmida
 deck show --all
 menu exit
- */
+menu enter Shop
+shop buy Yami
+shop buy Yami
+menu exit
+menu enter Deck
+deck add-card -c Yami -d oneParmida
+menu show-current
+deck show --all
+deck set-activate oneParmida
+menu exit
+duel -n -sp hamraz -r 3
+
+ */
\ No newline at end of file
Index: src/main/java/controller/ImportExportCardController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport model.*;\r\n\r\nimport java.io.*;\r\nimport java.util.List;\r\nimport java.util.Scanner;\r\n\r\npublic class ImportExportCardController {\r\n    private static ImportExportCardController instance = null;\r\n    private User user;\r\n\r\n    public static ImportExportCardController getInstance(User user) {\r\n        if (instance == null) instance = new ImportExportCardController(user);\r\n        else if (!instance.user.equals(user)) instance.user = user;\r\n        return instance;\r\n    }\r\n\r\n    private ImportExportCardController(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public void importCard(String cardName) {\r\n        int level = 0, attackPoint = 0, defencePoint = 0, price = 0, counter;\r\n        String attribute = \"\";\r\n        String monsterType = \"\";\r\n        String cardType = \"\";\r\n        String icon = \"\";\r\n        String status = \"\";\r\n        String description = \"\";\r\n        boolean canBeNormalSummoned = false;\r\n\r\n        File monsterFile = new File(\"Cards/\" + cardName + \"MonsterCard.txt\");\r\n        File trapFile = new File(\"Cards/\" + cardName + \"TrapCard.txt\");\r\n        File spellFile = new File(\"Cards/\" + cardName + \"SpellCard.txt\");\r\n        Scanner scanner = null;\r\n        try {\r\n            if (monsterFile.exists()) {\r\n                importMonsterCard(monsterFile);\r\n            }\r\n            if (trapFile.exists()) {\r\n                importTrapCard(trapFile);\r\n            }\r\n            if (spellFile.exists()) {\r\n                importSpellCard(spellFile);\r\n            }\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    private void importSpellCard(File spellFile) throws FileNotFoundException {\r\n        String icon;\r\n        String status;\r\n        int price;\r\n        String description;\r\n        int counter = 4;\r\n        Scanner scanner = new Scanner(spellFile);\r\n        while (scanner.hasNextLine()) {\r\n            if (counter == 4)\r\n                icon = scanner.nextLine();\r\n            if (counter == 3)\r\n                status = scanner.nextLine();\r\n            if (counter == 2)\r\n                price = Integer.parseInt(scanner.nextLine());\r\n            if (counter == 1) {\r\n                StringBuilder stringBuilder = new StringBuilder();\r\n                while (scanner.hasNextLine()) {\r\n                    stringBuilder.append(scanner.nextLine());\r\n                }\r\n                description = String.valueOf(stringBuilder);\r\n            }\r\n            if (counter == 0)\r\n                break;\r\n            counter--;\r\n        }\r\n/*\r\n                SpellCard spellCard = new SpellCard(icon,description,status,price)\r\n*/\r\n    }\r\n\r\n    private void importTrapCard(File trapFile) throws FileNotFoundException {\r\n        String icon;\r\n        String status;\r\n        int price;\r\n        String description;\r\n        int counter = 4;\r\n        Scanner scanner = new Scanner(trapFile);\r\n        while (scanner.hasNextLine()) {\r\n            if (counter == 4)\r\n                icon = scanner.nextLine();\r\n            if (counter == 3)\r\n                status = scanner.nextLine();\r\n            if (counter == 2)\r\n                price = Integer.parseInt(scanner.nextLine());\r\n            if (counter == 1) {\r\n                StringBuilder stringBuilder = new StringBuilder();\r\n                while (scanner.hasNextLine()) {\r\n                    stringBuilder.append(scanner.nextLine());\r\n                }\r\n                description = String.valueOf(stringBuilder);\r\n            }\r\n            if (counter == 0)\r\n                break;\r\n            counter--;\r\n        }\r\n/*\r\n                TrapCard trapCard = new TrapCard(icon,description,status,price);\r\n*/\r\n    }\r\n\r\n    private void importMonsterCard(File monsterFile) throws FileNotFoundException {\r\n        int counter;\r\n        String monsterType;\r\n        String cardType;\r\n        int defencePoint;\r\n        Scanner scanner;\r\n        int price;\r\n        int level;\r\n        boolean canBeNormalSummoned;\r\n        String attribute;\r\n        int attackPoint;\r\n        String description;\r\n        counter = 9;\r\n        scanner = new Scanner(monsterFile);\r\n        while (scanner.hasNextLine()) {\r\n            if (counter == 9)\r\n                level = Integer.parseInt(scanner.nextLine());\r\n            if (counter == 8)\r\n                attribute = scanner.nextLine();\r\n            if (counter == 7)\r\n                monsterType = scanner.nextLine();\r\n            if (counter == 6)\r\n                cardType = scanner.nextLine();\r\n            if (counter == 5)\r\n                attackPoint = Integer.parseInt(scanner.nextLine());\r\n            if (counter == 4)\r\n                defencePoint = Integer.parseInt(scanner.nextLine());\r\n            if (counter == 3)\r\n                price = Integer.parseInt(scanner.nextLine());\r\n            if (counter == 2)\r\n                canBeNormalSummoned = Boolean.parseBoolean(scanner.nextLine());\r\n            if (counter == 1) {\r\n                StringBuilder stringBuilder = new StringBuilder();\r\n                while (scanner.hasNextLine()) {\r\n                    stringBuilder.append(scanner.nextLine());\r\n                }\r\n                description = String.valueOf(stringBuilder);\r\n            }\r\n            if (counter == 0)\r\n                break;\r\n            counter--;\r\n        }\r\n/*                MonsterCard monsterCard = new MonsterCard(level, attribute, monsterType, cardType, attackPoint, defencePoint, description, price, canBeNormalSummoned) {\r\n                    @Override\r\n                    public void takeAction(DuelController duelController, TakeActionCase takeActionCase, User owner, int targetNumber) {\r\n\r\n                    }\r\n\r\n                    @Override\r\n                    public boolean canBeAttacked(DuelController duelController, int monsterNumber) {\r\n                        return false;\r\n                    }\r\n                };*/\r\n    }\r\n\r\n    public void exportCard(Cardable card) {\r\n        if (card instanceof MonsterCard)\r\n            exportMonsterCard(card);\r\n        if (card instanceof SpellCard)\r\n            ExportSpellCard(card);\r\n        if (card instanceof TrapCard)\r\n            ExportTrapCard(card);\r\n    }\r\n\r\n    private void ExportTrapCard(Cardable card) {\r\n        try {\r\n            FileWriter writer = new FileWriter(\"Cards/\" + card.getName() + \"TrapCard.txt\");\r\n            writer.write(((TrapCard) card).getIcon() + \"\\n\" + ((TrapCard) card).getStatus() + \"\\n\"\r\n                    + card.getPrice() + \"\\n\" + card.getDescription());\r\n        }catch (IOException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void ExportSpellCard(Cardable card) {\r\n        try {\r\n            FileWriter writer = new FileWriter(\"Cards/\" + card.getName() + \"SpellCard.txt\");\r\n            writer.write(((SpellCard) card).getIcon() + \"\\n\" + ((SpellCard) card).getStatus() + \"\\n\"\r\n                    + card.getPrice() + \"\\n\" + card.getDescription());\r\n        }catch (IOException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void exportMonsterCard(Cardable card) {\r\n        try {\r\n            FileWriter writer = new FileWriter(\"Cards/\" + card.getName() + \"MonsterCard.txt\");\r\n            writer.write(((MonsterCard) card).getLevel() + \"\\n\" + ((MonsterCard) card).getAttribute() + \"\\n\" +\r\n                    ((MonsterCard) card).getMonsterType() + \"\\n\" + ((MonsterCard) card).getCardType() + \"\\n\" +\r\n                    ((MonsterCard) card).getAttack() + \"\\n\" + ((MonsterCard) card).getDefence() + \"\\n\" +\r\n                    card.getPrice() + \"\\n\" + ((MonsterCard) card).getCanBeNormalSummoned() +\r\n                    \"\\n\" + card.getDescription());\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/controller/ImportExportCardController.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/controller/ImportExportCardController.java	(date 1624608162089)
@@ -75,9 +75,7 @@
                 break;
             counter--;
         }
-/*
-                SpellCard spellCard = new SpellCard(icon,description,status,price)
-*/
+//                SpellCard spellCard = new SpellCard(icon,description,status,price)
     }
 
     private void importTrapCard(File trapFile) throws FileNotFoundException {
Index: src/main/java/controller/LogInControllerGraphic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport controller.exeption.*;\r\nimport javafx.stage.Stage;\r\nimport model.User;\r\nimport view.LogInView;\r\nimport view.MainView;\r\nimport view.MainViewGraphic;\r\nimport view.SignUpViewGraphic;\r\n\r\npublic class LogInControllerGraphic {\r\n    public static void signup(Stage stage) throws Exception {\r\n        SignUpViewGraphic.getInstance().start(stage);\r\n    }\r\n\r\n    public static void login(String username, String password, Stage stage) throws Exception {\r\n        if (username.equals(\"\")) {\r\n            throw new EmptyUsernameBox();\r\n        }\r\n        if (password.equals(\"\")) {\r\n            throw new EmptyPasswordBox();\r\n        }\r\n        User user = User.getUserByUsername(username);\r\n        if (user == null) {\r\n            throw new UsernameNotFound();\r\n        } else if (!user.getPassword().equals(password)) {\r\n            throw new UsernameNotFound();\r\n        } else {\r\n            MainViewGraphic.getInstance().setCurrentUser(user);\r\n            MainViewGraphic.getInstance().start(stage);\r\n        }\r\n\r\n\r\n\r\n//        LogInController.getInstance().createUser(username,password,nickn);\r\n//        if (username.equals(\"\")) {\r\n//            throw new EmptyUsernameBox();\r\n//        }\r\n//        if (password.equals(\"\")) {\r\n//            throw new EmptyPasswordBox();\r\n//        }\r\n//        User user = User.getUserByUsername(username);\r\n//        if (User.getUserByUsername(username) == null || (!user.getPassword().equals(password))) {\r\n//            throw new WrongPasswordForSignInMenu();\r\n//        }\r\n//        MainViewGraphic.getInstance().setCurrentUser(user);\r\n//        MainViewGraphic.getInstance().start(stage);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/controller/LogInControllerGraphic.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/controller/LogInControllerGraphic.java	(date 1624608162103)
@@ -32,19 +32,19 @@
 
 
 
-//        LogInController.getInstance().createUser(username,password,nickn);
-//        if (username.equals("")) {
-//            throw new EmptyUsernameBox();
-//        }
-//        if (password.equals("")) {
-//            throw new EmptyPasswordBox();
-//        }
-//        User user = User.getUserByUsername(username);
-//        if (User.getUserByUsername(username) == null || (!user.getPassword().equals(password))) {
-//            throw new WrongPasswordForSignInMenu();
-//        }
-//        MainViewGraphic.getInstance().setCurrentUser(user);
-//        MainViewGraphic.getInstance().start(stage);
+        /*LogInController.getInstance().createUser(username,password,nickn);
+        if (username.equals("")) {
+            throw new EmptyUsernameBox();
+        }
+        if (password.equals("")) {
+            throw new EmptyPasswordBox();
+        }
+        User user = User.getUserByUsername(username);
+        if (User.getUserByUsername(username) == null || (!user.getPassword().equals(password))) {
+            throw new WrongPasswordForSignInMenu();
+        }
+        MainViewGraphic.getInstance().setCurrentUser(user);
+        MainViewGraphic.getInstance().start(stage);*/
     }
 
 }
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"BranchesTreeState\">\r\n    <expand>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"LOCAL_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n      <path>\r\n        <item name=\"ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"REMOTE_ROOT\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n        <item name=\"GROUP_NODE:origin\" type=\"e8cecc67:BranchNodeDescriptor\" />\r\n      </path>\r\n    </expand>\r\n    <select />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"0b1707ad-3e75-4310-9619-956ec670ae1a\" name=\"Default Changelist\" comment=\"draw phase automatic\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/allUsers.txt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/allUsers.txt\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/allCardshamriouz.txt\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Main.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Main.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/controller/DeckController.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/controller/DeckController.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/model/Deck.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/model/Deck.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/model/User.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/model/User.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/view/DeckView.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/view/DeckView.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"FxmlFile\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1tf7blqKJ2Y0dLvEX2lrUssvKzj\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"aspect.path.notification.shown\" value=\"true\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$/../project_team_17_3/src\" />\r\n    <property name=\"node.js.path.for.package.tslint\" value=\"project\" />\r\n    <property name=\"node.js.selected.package.tslint\" value=\"(autodetect)\" />\r\n    <property name=\"project.structure.last.edited\" value=\"SDKs\" />\r\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\r\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\r\n    <property name=\"restartRequiresConfirmation\" value=\"false\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"reference.projectsettings.compiler.javacompiler\" />\r\n  </component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyClassDialog.RECENTS_KEY\">\r\n      <recent name=\"controller.exeption\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Application.Main\">\r\n    <configuration default=\"true\" type=\"ArquillianTestNG\" factoryName=\"\" nameIsGenerated=\"true\">\r\n      <option name=\"arquillianRunConfiguration\">\r\n        <value>\r\n          <option name=\"containerStateName\" value=\"\" />\r\n        </value>\r\n      </option>\r\n      <option name=\"TEST_OBJECT\" value=\"CLASS\" />\r\n      <properties />\r\n      <listeners />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"ALTERNATIVE_JRE_PATH\" value=\"1.8\" />\r\n      <option name=\"ALTERNATIVE_JRE_PATH_ENABLED\" value=\"true\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Main\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"MainViewGraphic\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"view.MainViewGraphic\" />\r\n      <module name=\"project_team_17\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"view.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"ScoreBoardViewGraphic\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"view.ScoreBoardViewGraphic\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"view.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"SignUpViewGraphic\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"view.SignUpViewGraphic\" />\r\n      <module name=\"project_team_17_2\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"view.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"test.testForMinFinder\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"project_team_17_2\" />\r\n      <option name=\"PACKAGE_NAME\" value=\"\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"test\" />\r\n      <option name=\"METHOD_NAME\" value=\"testForMinFinder\" />\r\n      <option name=\"TEST_OBJECT\" value=\"method\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.Main\" />\r\n        <item itemvalue=\"JUnit.test.testForMinFinder\" />\r\n        <item itemvalue=\"Application.MainViewGraphic\" />\r\n        <item itemvalue=\"Application.SignUpViewGraphic\" />\r\n        <item itemvalue=\"Application.ScoreBoardViewGraphic\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"0b1707ad-3e75-4310-9619-956ec670ae1a\" name=\"Default Changelist\" comment=\"\" />\r\n      <created>1623148364579</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1623148364579</updated>\r\n      <workItem from=\"1624545878199\" duration=\"3232000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"ScoreBoardViewGraphic.java\">\r\n      <created>1623149665559</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623149665559</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"ScoreBoardViewGraphic.java\">\r\n      <created>1623149688409</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623149688409</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Error sign up\">\r\n      <created>1623151044078</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623151044078</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"model.SpellCard.java&#10;Monster Reborn + Terraforming\">\r\n      <created>1623868346229</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623868346229</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED\">\r\n      <created>1623946393997</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1623946393997</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"Yami SpellCard.java\">\r\n      <created>1624002906129</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624002906129</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Forest &amp; Closed Forest&#10;SpellCard.java\">\r\n      <created>1624012207305</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624012207305</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"debug import user\">\r\n      <created>1624093680512</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624093680512</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"debug import user o baghie import ha\">\r\n      <created>1624099929742</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624099929742</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"kiana test error fix\">\r\n      <created>1624533248061</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624533248061</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"show all cards debug\">\r\n      <created>1624546002241</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624546002241</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"jabejayie cheat money\">\r\n      <created>1624547044985</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624547044985</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"draw phase automatic\">\r\n      <created>1624556390073</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1624556390073</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"14\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n    <option name=\"oldMeFiltersMigrated\" value=\"true\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"ScoreBoardViewGraphic.java\" />\r\n    <MESSAGE value=\"Error sign up\" />\r\n    <MESSAGE value=\"model.SpellCard.java&#10;Monster Reborn + Terraforming\" />\r\n    <MESSAGE value=\"model.SpellCard.java&#10;RAIGEKI + POT_OF_GREED\" />\r\n    <MESSAGE value=\"Yami SpellCard.java\" />\r\n    <MESSAGE value=\"Forest &amp; Closed Forest&#10;SpellCard.java\" />\r\n    <MESSAGE value=\"debug import user\" />\r\n    <MESSAGE value=\"debug import user o baghie import ha\" />\r\n    <MESSAGE value=\"kiana test error fix\" />\r\n    <MESSAGE value=\"show all cards debug\" />\r\n    <MESSAGE value=\"jabejayie cheat money\" />\r\n    <MESSAGE value=\"draw phase automatic\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"draw phase automatic\" />\r\n  </component>\r\n  <component name=\"WindowStateProjectService\">\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.bottom\" timestamp=\"1624563654447\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.bottom/0.0.1280.680@0.0.1280.680\" timestamp=\"1624563654447\" />\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.center\" timestamp=\"1624563654447\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.center/0.0.1280.680@0.0.1280.680\" timestamp=\"1624563654447\" />\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.left\" timestamp=\"1624563654446\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.left/0.0.1280.680@0.0.1280.680\" timestamp=\"1624563654446\" />\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.right\" timestamp=\"1624563654447\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state width=\"1237\" height=\"138\" key=\"GridCell.Tab.0.right/0.0.1280.680@0.0.1280.680\" timestamp=\"1624563654447\" />\r\n    <state x=\"233\" y=\"74\" key=\"Vcs.Push.Dialog.v2\" timestamp=\"1624556391883\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"233\" y=\"74\" key=\"Vcs.Push.Dialog.v2/0.0.1280.680@0.0.1280.680\" timestamp=\"1624556391883\" />\r\n    <state x=\"297\" y=\"151\" key=\"run.anything.popup\" timestamp=\"1624560055229\">\r\n      <screen x=\"0\" y=\"0\" width=\"1280\" height=\"680\" />\r\n    </state>\r\n    <state x=\"297\" y=\"151\" key=\"run.anything.popup/0.0.1280.680@0.0.1280.680\" timestamp=\"1624560055229\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/workspace.xml	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ .idea/workspace.xml	(date 1624612785374)
@@ -23,14 +23,19 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="0b1707ad-3e75-4310-9619-956ec670ae1a" name="Default Changelist" comment="draw phase automatic">
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM_[Default_Changelist]/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_6_18_2021_12_08_PM__Default_Changelist_.xml" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/allUsers.txt" beforeDir="false" afterPath="$PROJECT_DIR$/allUsers.txt" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/allCardshamriouz.txt" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Users/hamraz.txt" beforeDir="false" afterPath="$PROJECT_DIR$/Users/hamraz.txt" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/Main.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Main.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/controller/DeckController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/DeckController.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/model/Deck.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/model/Deck.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/controller/DuelController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/DuelController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/controller/ImportExportCardController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/ImportExportCardController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/controller/ImportExportUserController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/ImportExportUserController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/controller/LogInControllerGraphic.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/LogInControllerGraphic.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/controller/ShopController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/controller/ShopController.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/model/User.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/model/User.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/view/DeckView.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/view/DeckView.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/view/MainView.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/view/MainView.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -47,6 +52,13 @@
   </component>
   <component name="Git.Settings">
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="MavenImportPreferences">
+    <option name="generalSettings">
+      <MavenGeneralSettings>
+        <option name="mavenHome" value="C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.2\plugins\maven\lib\maven3" />
+      </MavenGeneralSettings>
+    </option>
   </component>
   <component name="ProjectId" id="1tf7blqKJ2Y0dLvEX2lrUssvKzj" />
   <component name="ProjectViewState">
@@ -89,7 +101,7 @@
       <option name="ALTERNATIVE_JRE_PATH" value="1.8" />
       <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="true" />
       <option name="MAIN_CLASS_NAME" value="Main" />
-      <module name="project_team_17_2" />
+      <module name="project_team_17" />
       <method v="2">
         <option name="Make" enabled="true" />
       </method>
@@ -154,6 +166,11 @@
     </recent_temporary>
   </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="StructuralSearchPlugin">
+    <searchConfiguration name="Unnamed" created="1624607898327" text="/* $CommentContent$ */" recursive="false" caseInsensitive="false" type="JAVA" pattern_context="default" scope_type="PROJECT" scope_descriptor="" history="1">
+      <constraint name="__context__" within="" contains="" />
+    </searchConfiguration>
+  </component>
   <component name="TaskManager">
     <task active="true" id="Default" summary="Default task">
       <changelist id="0b1707ad-3e75-4310-9619-956ec670ae1a" name="Default Changelist" comment="" />
@@ -288,26 +305,34 @@
     <option name="LAST_COMMIT_MESSAGE" value="draw phase automatic" />
   </component>
   <component name="WindowStateProjectService">
-    <state width="1237" height="138" key="GridCell.Tab.0.bottom" timestamp="1624563654447">
+    <state x="170" y="166" width="942" height="348" key="#com.intellij.structuralsearch.plugin.ui.StructuralSearchDialog" timestamp="1624607898311">
       <screen x="0" y="0" width="1280" height="680" />
     </state>
-    <state width="1237" height="138" key="GridCell.Tab.0.bottom/0.0.1280.680@0.0.1280.680" timestamp="1624563654447" />
-    <state width="1237" height="138" key="GridCell.Tab.0.center" timestamp="1624563654447">
+    <state x="170" y="166" width="942" height="348" key="#com.intellij.structuralsearch.plugin.ui.StructuralSearchDialog/0.0.1280.680@0.0.1280.680" timestamp="1624607898311" />
+    <state width="1237" height="293" key="GridCell.Tab.0.bottom" timestamp="1624609982421">
       <screen x="0" y="0" width="1280" height="680" />
     </state>
-    <state width="1237" height="138" key="GridCell.Tab.0.center/0.0.1280.680@0.0.1280.680" timestamp="1624563654447" />
-    <state width="1237" height="138" key="GridCell.Tab.0.left" timestamp="1624563654446">
+    <state width="1237" height="293" key="GridCell.Tab.0.bottom/0.0.1280.680@0.0.1280.680" timestamp="1624609982421" />
+    <state width="1237" height="293" key="GridCell.Tab.0.center" timestamp="1624609982421">
       <screen x="0" y="0" width="1280" height="680" />
     </state>
-    <state width="1237" height="138" key="GridCell.Tab.0.left/0.0.1280.680@0.0.1280.680" timestamp="1624563654446" />
-    <state width="1237" height="138" key="GridCell.Tab.0.right" timestamp="1624563654447">
+    <state width="1237" height="293" key="GridCell.Tab.0.center/0.0.1280.680@0.0.1280.680" timestamp="1624609982421" />
+    <state width="1237" height="293" key="GridCell.Tab.0.left" timestamp="1624609982421">
       <screen x="0" y="0" width="1280" height="680" />
     </state>
-    <state width="1237" height="138" key="GridCell.Tab.0.right/0.0.1280.680@0.0.1280.680" timestamp="1624563654447" />
+    <state width="1237" height="293" key="GridCell.Tab.0.left/0.0.1280.680@0.0.1280.680" timestamp="1624609982421" />
+    <state width="1237" height="293" key="GridCell.Tab.0.right" timestamp="1624609982421">
+      <screen x="0" y="0" width="1280" height="680" />
+    </state>
+    <state width="1237" height="293" key="GridCell.Tab.0.right/0.0.1280.680@0.0.1280.680" timestamp="1624609982421" />
     <state x="233" y="74" key="Vcs.Push.Dialog.v2" timestamp="1624556391883">
       <screen x="0" y="0" width="1280" height="680" />
     </state>
     <state x="233" y="74" key="Vcs.Push.Dialog.v2/0.0.1280.680@0.0.1280.680" timestamp="1624556391883" />
+    <state x="458" y="255" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2" timestamp="1624612784928">
+      <screen x="0" y="0" width="1280" height="680" />
+    </state>
+    <state x="458" y="255" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.0.1280.680@0.0.1280.680" timestamp="1624612784928" />
     <state x="297" y="151" key="run.anything.popup" timestamp="1624560055229">
       <screen x="0" y="0" width="1280" height="680" />
     </state>
Index: src/main/java/controller/ShopController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport controller.exeption.*;\r\nimport model.*;\r\nimport view.ShopView;\r\n\r\n\r\nimport java.util.List;\r\n\r\npublic class ShopController {\r\n\r\n    private static ShopController instance = null;\r\n    private User user;\r\n\r\n    public static ShopController getInstance(User user) {\r\n        if (instance == null) instance = new ShopController(user);\r\n        else if (!instance.user.equals(user)) instance.user = user;\r\n        return instance;\r\n    }\r\n\r\n    private ShopController(User user) {\r\n        this.user = user;\r\n    }\r\n\r\n    public void buyCard(String name) throws Exception {\r\n        Cardable card = DeckController.getInstance(user).getCardByName(name);\r\n        if (card != null) {\r\n            if (this.user.getMoney() >= card.getPrice()) {\r\n                this.user.decreaseMoney(card.getPrice());\r\n                this.user.addCardToUsersAllCards(card);\r\n                ImportExportUserController importExportUserController = ImportExportUserController.getInstance();\r\n                importExportUserController.exportAllCards(this.user);\r\n                ShopView.getInstance(this.user).printText(\"The card \" + name + \" was successfully bought!\");\r\n            } else {\r\n                throw new NotEnoughMoney();\r\n            }\r\n        } else {\r\n            throw new CardNotFoundForController();\r\n        }\r\n    }\r\n\r\n    public void showAll() {\r\n        List<Cardable> allCards =  DeckController.getInstance(user).getAllCardsOfGame();\r\n        //TODO harja string=null bood =\"\" konim\r\n        String toPrint = \"\";\r\n        for (Cardable card : allCards){\r\n            if (allCards.indexOf(card) == allCards.size()-1){\r\n                toPrint += card.getNamePascalCase()+\":\"+card.getPrice();\r\n            } else\r\n                toPrint += card.getNamePascalCase()+\":\"+card.getPrice()+\"\\n\";\r\n        }\r\n        ShopView.getInstance(this.user).printText(toPrint);\r\n    }\r\n\r\n\r\n    /*private void logOUtUser() {\r\n\r\n    }*/\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/controller/ShopController.java	(revision 22932e90e451dcc040c0fc24093b3d8906b64c53)
+++ src/main/java/controller/ShopController.java	(date 1624608162089)
@@ -53,8 +53,4 @@
     }
 
 
-    /*private void logOUtUser() {
-
-    }*/
-
 }
